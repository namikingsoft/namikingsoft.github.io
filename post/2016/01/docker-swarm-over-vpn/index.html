<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=0.9"><title>クラウドとローカルをVPNでガッチャンコしたDockerネットワークを組んでみる - Namiking.net</title><link rel="stylesheet" href="/css/bundle.css"><script src="/js/bundle.js"></script></head><body><div class="layout-sitenavi"><div class="container"><div class="layout-sitenavi__title"><a href="http://blog.namiking.net/"><strong>Namiking.net</strong><p>Web系エンジニアの技術ブログ</p></a></div><div class="layout-sitenavi__menu"><ul><li><a href="http://blog.namiking.net/about/"><i class="fa fa-lg fa-user"></i><span>ABOUT</span></a></li><li><a href="https://github.com/namikingsoft/"><i class="fa fa-lg fa-github"></i><span>GITHUB</span></a></li><li><a href="https://twitter.com/namikingsoft/"><i class="fa fa-lg fa-twitter"></i><span>TWITTER</span></a></li></ul></div></div></div><div class="layout-headline-single"><div class="container"><header><div class="layout-headline-single__title"><h1>クラウドとローカルをVPNでガッチャンコしたDockerネットワークを組んでみる</h1></div><div class="lead"><div class="layout-headline-single__meta"><ul><li><i class="fa fa-calendar"></i>2016-01-22 (Fri)</li><li><img src="https://s.gravatar.com/avatar/3706c1a344dc2282c6683b6c6d0926f2?s=27&r=g">namikingsoft</li></ul></div><div class="layout-headline-single__taxonomies"><ul><li><a class="label label-success" href="/categories/docker-swarm">Docker Swarm</a></li><li><a class="label label-default" href="/tags/docker">docker</a></li><li><a class="label label-default" href="/tags/swarm">Swarm</a></li><li><a class="label label-default" href="/tags/vpn">VPN</a></li><li><a class="label label-default" href="/tags/softether">SoftEther</a></li></ul></div></div></header></div></div><div class="layout-content"><div class="container"><article><div class="layout-content__body"><div class="module-markdown">

<p>クラウド上で組んだDockerのオーバーレイネットワークの中に、屋内ファイアウォール内のマシンで組んでたDockerを参加させることができないか、試してみた。</p>

<h3 id="なぜに-余談">なぜに？ (余談)</h3>

<p>例えば、<a href="/post/2016/01/docker-swarm-spark/">以前の記事</a>のようにクラウドで組んだSparkクラスタを利用するために、Apache Zeppelin<sup class="footnote-ref" id="fnref:1"><a rel="footnote" href="#fn:1">1</a></sup>を使ってみたい。最初は、SSHトンネルやSocksプロキシで手軽にできないだろうかと色々やってみたが、Sparkは一方通行な通信ではなく、双方向な通信を行うため、クラウドからローカルのネットワークに直接アクセス(pingなど)できる必要があるようで、動作するには至らなかった。</p>

<p><img src="/images/post/2016/01/docker-swarm-over-vpn/zeppelin-local.svg" alt="Zeppelin on Local" /></p>

<p>Spark関連は基本的に同じネットワーク内で動かすのが前提の仕様なため、Swarmクラスタと同じネットワーク内に入れる必要があるが、Zeppelinは、</p>

<ul>
<li>割りとメモリ食い(推奨4GBほど)のため、Sparkクラスタと同じホストでは、動かしたくない。かといって、専用のホストを用意するできるブルジョアではない。</li>
<li>クラウドのSparkクラスタは使い終わったらすぐに破壊したいが、Zeppelinはnotebookや設定のデータを内部で持つため、作った後や消す前の同期が少し面倒。</li>
</ul>

<p>なので、できれば、ローカルネットワーク内にZeppelinを持っておきたい。</p>

<p><img src="/images/post/2016/01/docker-swarm-over-vpn/zeppelin-local-ideal.svg" alt="Zeppelin on Local Ideal" /></p>

<h3 id="この記事でやること">この記事でやること</h3>

<p>上のApache Sparkの例は置いといて、今回は取り急ぎクラウドとローカルを跨いだSwarmクラスタを構築して、Dockerオーバーレイネットワークの疎通確認を行いたい。検証のため、以下の図の様な構成を準備して、オーバーレイネットワークの疎通を確認する。</p>

<p><img src="/images/post/2016/01/docker-swarm-over-vpn/docker-swarm-over-vpn.svg" alt="Zeppelin on Local Ideal" /></p>

<h5 id="要点">要点</h5>

<ul>
<li>ローカル環境とクラウドのDockerをVPNを用いて、オーバーレイネットワークで繋ぎたい。</li>
<li>VPN接続には、SoftEther VPN<sup class="footnote-ref" id="fnref:2"><a rel="footnote" href="#fn:2">2</a></sup>を使ってみる。</li>
<li>ローカル側とクラウド側１台ずつ、Swarm Masterをレプリケーションした。

<ul>
<li>クラウドのみでも、Swarmクラスタとして機能させたかったため。</li>
<li>ローカルの作業用PCは、いちいちVPNに接続しなくても、Swarmクラスタを操作できるようにするため。</li>
</ul></li>
</ul>

<h3 id="事前準備">事前準備</h3>

<h4 id="必要なソフトウェアのインストール">必要なソフトウェアのインストール</h4>

<p>作業で使うPC(またはホスト)に以下のソフトウェアをインストールしておく。</p>

<ul>
<li>docker (バージョン1.9以上, オーバーレイネットワーク機能を使う)</li>
<li>docker-compose (動作検証に使うだけなので任意)</li>
<li>Virtualbox (vagrantを併用してもよい)</li>
</ul>

<h4 id="digitaloceanの登録とアクセストークンの取得">DigitalOceanの登録とアクセストークンの取得</h4>

<p>登録後、管理画面からdocker-machineとの連携に必要なアクセストークンを発行できる。</p>

<p><a href="https://www.digitalocean.com/">https://www.digitalocean.com/</a></p>

<h3 id="ノード用のホストを用意する">ノード用のホストを用意する</h3>

<p>今回の例では、DigitalOceanでノードを２台とローカルでVirtualbox１台を用意する。</p>

<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Host</th>
<th align="left">OS</th>
<th align="left">Mem</th>
<th align="left">VPNのIP</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">DigitalOcean</td>
<td align="left"><strong>swarm-node0</strong></td>
<td align="left">ubuntu-15-10-x64</td>
<td align="left">512MB</td>
<td align="left">192.168.30.2 (手動)</td>
</tr>

<tr>
<td align="left">DigitalOcean</td>
<td align="left"><strong>swarm-node1</strong></td>
<td align="left">ubuntu-15-10-x64</td>
<td align="left">512MB</td>
<td align="left">192.168.30.x (自動)</td>
</tr>

<tr>
<td align="left">Vitualbox(local)</td>
<td align="left"><strong>swarm-local</strong></td>
<td align="left">ubuntu-15-10-x64</td>
<td align="left">-</td>
<td align="left">192.168.30.y (自動)</td>
</tr>
</tbody>
</table>

<h5 id="備考">備考</h5>

<ul>
<li>swarm-node0はマスターノードとして使う</li>
<li>ホスト名(hostname)は別になんでもよい</li>
<li>プライベートネットワークは無効にしておく</li>
<li>VPNのIPについては、VPN接続後に割り当てる。</li>
</ul>

<h3 id="softether-vpn-serverを動かす">SoftEther VPN Serverを動かす</h3>

<p>swarm-node0にSSHなどでログインして、作業を行う。</p>

<p>Linux版については、<a href="https://ja.softether.org/">SoftEther VPNのサイト</a>からソースコードをダウンロードして、コンパイルする。後で自動化しやすいように、GUIやインタラクティブCUIを使わないように書いておく。</p>

<h4 id="ダウンロード">ダウンロード</h4>

<pre><code class="language-sh"># 必要なパッケージのインストール
apt-get install -y curl gcc make

# SoftEther VPN ソースのダウンロード
cd /usr/local/src
curl -LO http://jp.softether-download.com/files/softether/v4.19-9599-beta-2015.10.19-tree/Linux/SoftEther_VPN_Server/64bit_-_Intel_x64_or_AMD64/softether-vpnserver-v4.19-9599-beta-2015.10.19-linux-x64-64bit.tar.gz
tar xzf softether-vpnserver-v4.19-9599-beta-2015.10.19-linux-x64-64bit.tar.gz
</code></pre>

<h4 id="コンパイルとインストール">コンパイルとインストール</h4>

<pre><code class="language-sh"># コンパイル
cd vpnserver
make i_read_and_agree_the_license_agreement

# PATH設定
export PATH=&quot;/usr/local/src/vpnserver:$PATH&quot;
echo 'export PATH=&quot;/usr/local/src/vpnserver:$PATH&quot;' &gt;&gt; /etc/profile
</code></pre>

<h4 id="サービス登録と起動-systemd">サービス登録と起動 (systemd)</h4>

<pre><code class="language-sh"># サービス登録
cat &lt;&lt; EOS &gt; /lib/systemd/system/vpnserver.service
[Unit]
Description=SoftEther VPN Server
After=network.target

[Service]
Type=forking
ExecStart=/usr/local/src/vpnserver/vpnserver start
ExecStop=/usr/local/src/vpnserver/vpnserver stop

[Install]
WantedBy=multi-user.target
EOS

# 自動起動設定＆起動
systemctl enable vpnserver
systemctl start vpnserver
</code></pre>

<h4 id="vpnサーバー設定">VPNサーバー設定</h4>

<pre><code class="language-sh"># 各種設定項目 (値は任意で決める)
export HUBNAME=cluster
export HUBPASS=password
export USERNAME=user
export USERPASS=something
export SHAREDKEY=sharedkey

# 仮想HUB作成
vpncmd localhost /SERVER /CMD HubCreate $HUBNAME \
  /PASSWORD:$HUBPASS &amp;&amp; true

# SNAT＆DHCP有効化
vpncmd localhost /SERVER /HUB:$HUBNAME /PASSWORD:$HUBPASS /CMD \
  SecureNatEnable

# ユーザー登録
vpncmd localhost /SERVER /HUB:$HUBNAME /PASSWORD:$HUBPASS /CMD \
  UserCreate $USERNAME \
  /GROUP:none \
  /REALNAME:none \
  /NOTE:none

# ユーザーパスワード設定
vpncmd localhost /SERVER /HUB:$HUBNAME /PASSWORD:$HUBPASS /CMD \
  UserPasswordSet $USERNAME \
  /PASSWORD:$USERPASS

# IPsec VPN有効化
vpncmd localhost /SERVER /CMD \
  IPsecEnable \
  /L2TP:yes \
  /L2TPRAW:no \
  /ETHERIP:yes \
  /PSK:$SHAREDKEY \
  /DEFAULTHUB:$HUBNAME
</code></pre>

<p>VPN設定のリファレンスは以下を参照。<br />
<a href="https://ja.softether.org/4-docs/1-manual/6/6.4">https://ja.softether.org/4-docs/1-manual/6/6.4</a></p>

<h3 id="softether-vpn-clientを動かす">SoftEther VPN Clientを動かす</h3>

<p>全てのノードにSSHなどでログインして、作業を行う。<br />
Serverと同じく、<a href="https://ja.softether.org/">SoftEther VPNのサイト</a>からソースコードをダウンロードして、コンパイルする。</p>

<h4 id="ダウンロード-1">ダウンロード</h4>

<pre><code class="language-sh"># 必要なパッケージのインストール
apt-get install -y curl gcc make

# SoftEther VPN ソースのダウンロード
cd /usr/local/src
curl -LO http://jp.softether-download.com/files/softether/v4.19-9599-beta-2015.10.19-tree/Linux/SoftEther_VPN_Client/64bit_-_Intel_x64_or_AMD64/softether-vpnclient-v4.19-9599-beta-2015.10.19-linux-x64-64bit.tar.gz
tar xzf softether-vpnclient-v4.19-9599-beta-2015.10.19-linux-x64-64bit.tar.gz
rm softether-vpnclient-v4.19-9599-beta-2015.10.19-linux-x64-64bit.tar.gz
</code></pre>

<h4 id="コンパイルとインストール-1">コンパイルとインストール</h4>

<pre><code class="language-sh"># コンパイル
cd vpnclient
make i_read_and_agree_the_license_agreement

# PATH設定
export PATH=&quot;/usr/local/src/vpnclient:$PATH&quot;
echo 'export PATH=&quot;/usr/local/src/vpnclient:$PATH&quot;' &gt;&gt; /etc/profile
</code></pre>

<h4 id="サービス登録と起動-systemd-1">サービス登録と起動 (systemd)</h4>

<pre><code class="language-sh"># サービス登録
cat &lt;&lt; EOS &gt; /lib/systemd/system/vpnclient.service
[Unit]
Description=SoftEther VPN Client
After=network.target

[Service]
Type=forking
ExecStart=/usr/local/src/vpnclient/vpnclient start
ExecStop=/usr/local/src/vpnclient/vpnclient stop

[Install]
WantedBy=multi-user.target
EOS

# 自動起動設定＆起動
systemctl enable vpnclient
systemctl start vpnclient
</code></pre>

<h4 id="vpnサーバー設定-1">VPNサーバー設定</h4>

<pre><code class="language-sh"># 各種設定項目 (基本的にはServerの値と合わせる)
ACCOUNT=private
NICNAME=vlan0
SERVER=&quot;(swarm-node0のグローバルIP):443&quot;
HUBNAME=cluster
USERNAME=user
USERPASS=something

# クライアント管理へのリモートログインを無効
vpncmd localhost /CLIENT /CMD RemoteDisable

# NIC作成 (この例だと、vpn_vlan0というインタフェースが作成される)
vpncmd localhost /CLIENT /CMD NicCreate $NICNAME

# アカウント作成
vpncmd localhost /CLIENT /CMD AccountCreate $ACCOUNT \
  /SERVER:$SERVER \
  /HUB:$HUBNAME \
  /USERNAME:$USERNAME \
  /NICNAME:$NICNAME

# アカウントパスワード設定
vpncmd localhost /CLIENT /CMD AccountPasswordSet $ACCOUNT \
  /PASSWORD:$USERPASS \
  /TYPE:standard

# アカウント自動起動設定
vpncmd localhost /CLIENT /CMD AccountStartupSet $ACCOUNT

# アカウント接続
vpncmd localhost /CLIENT /CMD AccountConnect $ACCOUNT

# swarm-node0では固定IP割り当て
ip addr add 192.168.30.2/24 dev vpn_$NICNAME

# その他ノードは自動割り当て
dhclient vpn_$NICNAME
</code></pre>

<p>swarm-node0だけは、DHCPでIPを振らずに固定IPを設定する。</p>

<h4 id="vpn接続確認">VPN接続確認</h4>

<p>SoftEther VPNのClientのセッティングが完了すると、以下の様な成果が出る。</p>

<ul>
<li>各ノードに<code>vpn_vlan0</code>というインタフェースができる。

<ul>
<li>vpn_vlan0を通して、pingなどの疎通ができるようになる。</li>
</ul></li>
<li>各ノードに192.168.30.0/24のネットワークのIPが割り当てられる。

<ul>
<li>192.168.30.0/24はSoftEther VPNのデフォルト設定。</li>
<li>DHCPで割り当てると、192.168.30.10〜が振られる。</li>
</ul></li>
</ul>

<p>これから設置するConsulやDockerは、このネットワークにのせるように設定する。</p>

<h3 id="各ノードでconsulを動かす">各ノードでConsulを動かす</h3>

<p>インストールとサービス登録手順については、<a href="/post/2016/01/docker-swarm-build-using-tls#各ノードでconsulを動かす:357fa4bd2e644c21db7997b0a9ea5cf8">以前の記事</a>にまとめてあるので参照されたい。ここではConsulサーバーの設定手順を示す。</p>

<h4 id="swarm-node0にてサーバーモードで動かす設定">swarm-node0にてサーバーモードで動かす設定</h4>

<p>SSHでログインして、作業を行う。</p>

<pre><code class="language-sh"># 自分自身のVPNのIPを取得
export MY_VPN_IP=$(
  ip addr show vpn_vlan0 \
  | grep -o -e '[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+' \
  | head -n1
)

# 設定ファイルに書き出す
cat &lt;&lt; EOS &gt; /etc/consul.d/config.json
{
  &quot;server&quot;: true,
  &quot;bootstrap&quot;: true,
  &quot;bind_addr&quot;: &quot;$MY_VPN_IP&quot;,
  &quot;datacenter&quot;: &quot;swarm0&quot;,
  &quot;ui_dir&quot;: &quot;/var/local/consul/webui&quot;,
  &quot;data_dir&quot;: &quot;/var/local/consul/data&quot;,
  &quot;log_level&quot;: &quot;INFO&quot;,
  &quot;enable_syslog&quot;: true
}
EOS
</code></pre>

<p>VPNネットワークである<code>vpn_vlan0</code>のIPにバインドする。<br />
設定が終わったら、自動起動設定と起動を行っておく。</p>

<pre><code class="language-sh">systemctl enable consul
systemctl start consul
</code></pre>

<h4 id="swarm-node1とswarm-localにてクライアントモードで動かす設定">swarm-node1とswarm-localにてクライアントモードで動かす設定</h4>

<p>SSHでログインして、作業を行う。</p>

<pre><code class="language-sh"># 自分自身のvpnのipを取得
export my_vpn_ip=$(
  ip addr show vpn_vlan0 \
  | grep -o -e '[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+' \
  | head -n1
)

# 設定ファイルに書き出す
cat &lt;&lt; eos &gt; /etc/consul.d/config.json
{
  &quot;server&quot;: false,
  &quot;start_join&quot;: [&quot;192.168.30.2&quot;],
  &quot;bind_addr&quot;: &quot;$MY_VPN_IP&quot;,
  &quot;datacenter&quot;: &quot;swarm0&quot;,
  &quot;ui_dir&quot;: &quot;/var/local/consul/webui&quot;,
  &quot;data_dir&quot;: &quot;/var/local/consul/data&quot;,
  &quot;log_level&quot;: &quot;INFO&quot;,
  &quot;enable_syslog&quot;: true
}
EOS
</code></pre>

<p>joinするIPは固定で割り当てたswarm-node0のものを指定。<br />
設定が終わったら、自動起動設定と起動を行っておく。</p>

<pre><code class="language-sh">systemctl enable consul
systemctl start consul
</code></pre>

<h4 id="メンバー確認">メンバー確認</h4>

<p>各ノードのConsulが連携できているかを確認する。</p>

<pre><code class="language-sh">$ consul members

Node     Address            Status  Type    Build  Protocol  DC
******  192.168.30.2:8301   alive   server  0.6.1  2         swarm0
******  192.168.30.10:8301   alive   client  0.6.1  2         swarm0
******  192.168.30.11:8301   alive   client  0.6.1  2         swarm0
</code></pre>

<p>WebUIで確認する場合、ローカルPCのOS設定などから、swarm-node0へVPN接続を行えば、ブラウザで閲覧できる。</p>

<pre><code class="language-sh">open http://192.168.30.2:8500
</code></pre>

<h3 id="各ノードでdockerを動かす">各ノードでDockerを動かす</h3>

<ul>
<li>全3ノードに対して、SSHでログインして作業を行う。</li>
<li>リモートからDockerを操作するため、TCPの2375ポートを使う。</li>
<li>リモートからSwarmマスターを操作するために、TCPの3375ポートを使う。</li>
<li>VPNネットワークがあるので、TLS認証は使わない。</li>
<li>ただし、<code>vpn_vlan0</code>以外はポートをファイアウォールで閉じておく。</li>
</ul>

<h4 id="インストール">インストール</h4>

<pre><code class="language-sh">wget -qO- https://get.docker.com/ | sh
</code></pre>

<h4 id="ファイアウォール設定">ファイアウォール設定</h4>

<pre><code class="language-sh">iptables -A INPUT -i eth0 -p tcp -m tcp --dport 2375 -j DROP
iptables -A INPUT -i eth0 -p tcp -m tcp --dport 3375 -j DROP
</code></pre>

<p>DigitalOceanのノードのみでよい。</p>

<h4 id="dockerデーモン起動時の引数設定">Dockerデーモン起動時の引数設定</h4>

<pre><code class="language-sh">vi /lib/systemd/system/docker.service

# 変更前
ExecStart=/usr/bin/docker daemon -H fd://
# 変更後
ExecStart=/usr/bin/docker daemon \
  -H=0.0.0.0:2375\
  --cluster-store=consul://localhost:8500 \
  --cluster-advertise=vpn_vlan0:2375 \
  -H fd://
</code></pre>

<p>変更後は見やすさのため複数行で書いているが、<code>\</code>を消して1行ぶっ続けで記述する。</p>

<h4 id="docker再起動">Docker再起動</h4>

<pre><code class="language-sh">service docker restart
</code></pre>

<h3 id="各ノードでswarmコンテナを動かす">各ノードでSwarmコンテナを動かす</h3>

<p>各ノードにSSHでログインして、Swarmコンテナを起動させる。</p>

<h4 id="swarm-node0-swarm-local">swarm-node0, swarm-local</h4>

<pre><code class="language-sh"># Swarm Manager
docker run -d --name=swarm-agent-master \
  -v=/etc/docker:/etc/docker --net=host --restart=always \
  swarm manage -H=0.0.0.0:3375 --replication \
    --strategy=spread --advertise=192.168.30.2:3375 consul://localhost:8500

# Swarm Agent
docker run -d --name=swarm-agent --net=host --restart=always \
  swarm join --advertise=192.168.30.2:2375 consul://localhost:8500
</code></pre>

<p>Swarm Managerについては、双方レプリケーションするために<code>--replication</code>引数をつける。</p>

<h4 id="swarm-node1">swarm-node1</h4>

<pre><code class="language-sh"># Swarm Agent
docker run -d --name=swarm-agent --net=host --restart=always \
  swarm join --advertise=192.168.30.x:2375 consul://localhost:8500
</code></pre>

<p><code>192.168.30.x</code>のところには、swarm-node1がVPNのDHCPに割り当てられたのIPを入れる。</p>

<h4 id="swarm-local">swarm-local</h4>

<pre><code class="language-sh"># Swarm Manager
docker run -d --name=swarm-agent-master \
  -v=/etc/docker:/etc/docker --net=host --restart=always \
  swarm manage -H=0.0.0.0:3375 --replication \
    --strategy=spread --advertise=192.168.30.y:3375 consul://localhost:8500

# Swarm Agent
docker run -d --name=swarm-agent --net=host --restart=always \
  swarm join --advertise=192.168.30.y:2375 consul://localhost:8500
</code></pre>

<p><code>192.168.30.y</code>のところには、swarm-localがVPNのDHCPに割り当てられたIPを入れる。</p>

<h3 id="動作確認">動作確認</h3>

<h4 id="ローカルpcのos設定にて-vpn接続を行う">ローカルPCのOS設定にて、VPN接続を行う</h4>

<p>Macであれば、<a href="http://ja.softether.org/4-docs/2-howto/L2TP_IPsec_Setup_Guide/5">SoftEther VPNのドキュメント</a>を参考にして、設定を行う。入力値に関しては、この記事の通りにやった場合は以下のようになる。</p>

<ul>
<li>サーバーアドレス: (swarm-node0のグローバルIP)</li>
<li>ユーザーID: user</li>
<li>パスワード: something</li>
<li>共有シークレット： sharedkey</li>
</ul>

<h4 id="ローカルpcから-swarmマスターに接続してみる">ローカルPCから、Swarmマスターに接続してみる</h4>

<p>ターミナルなどから以下のコマンドを入力して、Swarmクラスタの接続状況を確認してみる。</p>

<pre><code class="language-sh">$ docker -H=192.168.30.2:3375 info

Containers: 4
Images: 4
Role: primary
Strategy: spread
Filters: health, port, dependency, affinity, constraint
Nodes: 3
 swarm-local: 192.168.30.11:2375
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 1
  └ Reserved Memory: 0 B / 4.053 GiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.2.0-25-generic, operatingsystem=Ubuntu 15.10, storagedriver=aufs
 swarm-node0: 192.168.30.2:2375
  └ Status: Healthy
  └ Containers: 2
  └ Reserved CPUs: 0 / 1
  └ Reserved Memory: 0 B / 513.4 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.2.0-16-generic, operatingsystem=Ubuntu 15.10, storagedriver=aufs
 swarm-node1: 192.168.30.10:2375
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 1
  └ Reserved Memory: 0 B / 513.4 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.2.0-16-generic, operatingsystem=Ubuntu 15.10, storagedriver=aufs
CPUs: 3
Total Memory: 5.055 GiB
Name: swarm-node0
</code></pre>

<p>ノードが３つ接続されていれば、クラウドとローカルを跨いだSwarmクラスタの構築に成功している状態になる。</p>

<p>ちなみに、<code>-H=192.168.30.2:3375</code>の部分は、環境変数<code>DOCKER_HOST</code>に<code>192.168.30.2:3375</code>と設定しておけば省略できる。</p>

<h4 id="各ノードにコンテナを置いてみる">各ノードにコンテナを置いてみる</h4>

<h5 id="オーバーレイネットワークの作成">オーバーレイネットワークの作成</h5>

<pre><code class="language-sh">export DOCKER_HOST=&quot;192.168.30.2:3375&quot;
docker network create testnet
</code></pre>

<p>Swarmマスターへの接続であれば、デフォルトでドライバが<code>overlay</code>に設定される。</p>

<h5 id="docker-compose-yml">docker-compose.yml</h5>

<pre><code class="language-ruby">nginx:
  image: nginx
  net: testnet
  ports:
    - &quot;8080:80&quot;
</code></pre>

<p>portsを設定しておけば、コンフリクトを防ぐため、コンテナ配置が自然とバラける。</p>

<h5 id="docker-compose-up-scale">docker-compose up &amp; scale</h5>

<pre><code class="language-sh">docker-compose up -d
docker-compose scale nginx=3
</code></pre>

<h5 id="コンテナ配置確認">コンテナ配置確認</h5>

<pre><code class="language-sh">$ docker ps --format &quot;{{.Names}}&quot;

swarm-node0/****_nginx_3
swarm-node1/****_nginx_2
swarm-local/****_nginx_1
</code></pre>

<p>ちゃんとすべてのホストにコンテナが配置できることを確認。<code>http://192.168.30.x:8080/</code>各々をブラウザで打ちこめば、nginxのデフォルトページが表示されるはず。</p>

<p>あとは、コンテナの中に<code>docker exec</code>で入って、<code>/etc/hosts</code>の中を見れば、他のコンテナのIPが書いてあるはずなので、pingを打ってみたりで、オーバーレイネットワークの疎通を確認できる。</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:1"><a href="https://zeppelin.incubator.apache.org/">Zeppelin</a>はWeb上からSparkの操作をインタラクティブに行えたり、結果をビジュアライズできたりする、ノートブック系Webアプリ
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
<li id="fn:2">TCP/IPベースのVPNで、動かしてみたら割とすんなり動作したので、これを使ってみた。PPTPdも試したが、<a href="http://askubuntu.com/questions/621820/pptpd-failed-after-upgrading-ubuntu-server-to-15">Ubuntu15.10で上手く動作しなかった</a>ので、見送り
 <a class="footnote-return" href="#fnref:2"><sup>[return]</sup></a></li>
</ol>
</div>
</div></div><div class="layout-content__comment"><div class="module-comment"><div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'namikingsoft';
    var disqus_identifier = 'http:\/\/blog.namiking.net\/post\/2016\/01\/docker-swarm-over-vpn\/';
    var disqus_title = 'クラウドとローカルをVPNでガッチャンコしたDockerネットワークを組んでみる';
    var disqus_url = 'http:\/\/blog.namiking.net\/post\/2016\/01\/docker-swarm-over-vpn\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div></div></article></div></div><div class="layout-pagenavi"><div class="container"><div class="layout-pagenavi__relate"><div class="module-relate"></div></div><div class="layout-pagenavi__paging"><div class="module-paging"><div class="module-paging__prev col-xs-6"><a href="/post/2016/01/spark-mllib-regression/" title="Sparkで機械学習： 回帰モデルで値を予測する"><i class="fa fa-arrow-circle-o-left"></i><p class="hidden-xs">2016-01-31 (Sun)</p></a></div><div class="module-paging__next col-xs-6"><a href="/post/2016/01/docker-swarm-build-using-tls/" title="TLS認証なDocker Swarmクラスタを構築 (docker-machineなしで)"><i class="fa fa-arrow-circle-o-right"></i><p class="hidden-xs">2016-01-18 (Mon)</p></a></div></div></div></div></div><div class="layout-sharenavi"><div class="container"><h4>この記事について</h4><div class="layout-sharenavi__profile"><div class="module-profile"><div class="module-profile__avatar"><img src="https://s.gravatar.com/avatar/3706c1a344dc2282c6683b6c6d0926f2?s=80&r=g"><small>書いた人<br>Written by</small></div><div class="module-profile__text"><h3>namikingsoft</h3><p>何かを残して逝きたい<br>フロントエンドエンジニア</p><ul><li><a href="http://blog.namiking.net/about/"><i class="fa fa-2x fa-user"></i></a></li><li><a href="https://github.com/namikingsoft/"><i class="fa fa-2x fa-github"></i></a></li><li><a href="https://twitter.com/namikingsoft/"><i class="fa fa-2x fa-twitter"></i></a></li></ul></div></div></div><div class="layout-sharenavi__sharelink"><div class="module-sharelink"><ul class="module-sharelink__list"><li class="module-sharelink__list-twitter"><a class="twitter-share-button" data-url="http://blog.namiking.net/post/2016/01/docker-swarm-over-vpn/" href="https://twitter.com/share" data-lang="ja" data-count="vertical" data-dnt="true">ツイート</a></li><li class="module-sharelink__list-facebook"><div class="fb-like" data-href="http://blog.namiking.net/post/2016/01/docker-swarm-over-vpn/" data-layout="box_count" data-action="like" data-show-faces="true" data-share="false"></div></li><li class="module-sharelink__list-google"><div class="g-plusone" data-href="http://blog.namiking.net/post/2016/01/docker-swarm-over-vpn/" data-size="tall"></div></li><li class="module-sharelink__list-hatena"><a class="hatena-bookmark-button" href="http://b.hatena.ne.jp/entry/http://blog.namiking.net/post/2016/01/docker-swarm-over-vpn/" data-hatena-bookmark-layout="vertical-balloon" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border:none;"></a></li><li class="module-sharelink__list-pocket"><a class="pocket-btn" data-save-url="http://blog.namiking.net/post/2016/01/docker-swarm-over-vpn/" data-pocket-label="pocket" data-pocket-count="vertical" data-lang="en"></a></li><li class="module-sharelink__list-line"><a href="http://line.me/R/msg/text/?http%3a%2f%2fblog.namiking.net%2fpost%2f2016%2f01%2fdocker-swarm-over-vpn%2f"><img src="/images/button/linebutton_36x60.png" width="36" height="60" alt="LINEに送る"></a></li></ul><div id="fb-root"></div></div></div></div></div><div class="layout-footer"><div class="container"><div class="layout-footer__poweredby col-sm-4"><div class="module-poweredby"><div class="module-poweredby__title"><a href="http://blog.namiking.net/"><strong>Namiking.net</strong><p>Web系エンジニアの技術ブログ</p></a></div><div class="module-poweredby__menu"><ul><li><a href="http://blog.namiking.net/"><i class="fa fa-lg fa-home"></i><span>HOME</span></a></li><li><a href="http://blog.namiking.net/about/"><i class="fa fa-lg fa-user"></i><span>ABOUT</span></a></li><li><a href="https://github.com/namikingsoft/"><i class="fa fa-lg fa-github"></i><span>GITHUB</span></a></li><li><a href="https://twitter.com/namikingsoft/"><i class="fa fa-lg fa-twitter"></i><span>TWITTER</span></a></li><li><a href="http://blog.namiking.net/index.xml"><i class="fa fa-lg fa-rss"></i><span>RSS</span></a></li></ul></div><div class="module-poweredby__hugo"><p>Designed &amp; Written by <a href="/about">@namikingsoft</a></p><p>Powered by <a href="http://gohugo.io">HUGO</a></p></div></div></div><div class="layout-footer__recent col-sm-4"><div class="module-recent"><h3>Recent Post</h3><dl><dt>2016-05-22 (Sun)</dt><dd><a href="/post/2016/05/react-redux-using-flow-example/">静的型チェッカーflowでReact&#43;Reduxのサンプルアプリを組んでみた</a></dd><dt>2016-05-12 (Thu)</dt><dd><a href="/post/2016/05/flow-class-private-fields/">静的型チェッカーflowのクラスでPrivateなフィールドを定義するメモ</a></dd><dt>2016-05-12 (Thu)</dt><dd><a href="/post/2016/05/flow-disadvantage/">静的型チェッカーflowを使ってみて、微妙に気になったこと４つ</a></dd><dt>2016-02-13 (Sat)</dt><dd><a href="/post/2016/02/react-server-using-webpack/">サーバーサイドReactをwebpackを使って最小構成で試す (ES6 ＆ TypeScript)</a></dd><dt>2016-01-31 (Sun)</dt><dd><a href="/post/2016/01/spark-mllib-regression/">Sparkで機械学習： 回帰モデルで値を予測する</a></dd></dl></div></div><div class="layout-footer__tagcloud col-sm-4"><div class="module-tagcloud"><h3>Tags</h3><ul><li><a href="/tags/ddd">ddd(1)</a></li><li><a href="/tags/digitalocean">digitalocean(1)</a></li><li><a href="/tags/docker">docker(9)</a></li><li><a href="/tags/docker-compose">docker-compose(1)</a></li><li><a href="/tags/ecmascript">ecmascript(4)</a></li><li><a href="/tags/eslint">eslint(1)</a></li><li><a href="/tags/express">express(1)</a></li><li><a href="/tags/flow">flow(3)</a></li><li><a href="/tags/flowtype">flowtype(3)</a></li><li><a href="/tags/javascript">javascript(3)</a></li><li><a href="/tags/libreboard">libreboard(1)</a></li><li><a href="/tags/mocha">mocha(1)</a></li><li><a href="/tags/oss">oss(4)</a></li><li><a href="/tags/react">react(2)</a></li><li><a href="/tags/redux">redux(1)</a></li><li><a href="/tags/restyaboard">restyaboard(2)</a></li><li><a href="/tags/softether">softether(1)</a></li><li><a href="/tags/spark">spark(2)</a></li><li><a href="/tags/swarm">swarm(4)</a></li><li><a href="/tags/taiga">taiga(2)</a></li><li><a href="/tags/terraform">terraform(1)</a></li><li><a href="/tags/tls">tls(1)</a></li><li><a href="/tags/typescript">typescript(1)</a></li><li><a href="/tags/vpn">vpn(1)</a></li><li><a href="/tags/webpack">webpack(2)</a></li><li><a href="/tags/webpack-dev-server">webpack-dev-server(1)</a></li><li><a href="/tags/wekan">wekan(2)</a></li><li><a href="/tags/zeppelin">zeppelin(1)</a></li><li><a href="/tags/%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9">インフラ(2)</a></li><li><a href="/tags/%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92">機械学習(1)</a></li><li><a href="/tags/%E6%B1%BA%E5%AE%9A%E6%9C%A8%E5%9B%9E%E5%B8%B0">決定木回帰(1)</a></li><li><a href="/tags/%E7%B7%9A%E5%BD%A2%E5%9B%9E%E5%B8%B0">線形回帰(1)</a></li></ul></div></div></div></div></body></html>