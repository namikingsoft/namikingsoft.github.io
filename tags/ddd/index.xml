<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ddd on Namiking.net</title>
    <link>http://blog.namiking.net/tags/ddd/</link>
    <description>Recent content in Ddd on Namiking.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp-ja</language>
    <lastBuildDate>Thu, 12 May 2016 08:00:00 +0900</lastBuildDate>
    <atom:link href="http://blog.namiking.net/tags/ddd/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>静的型チェッカーflowのクラスでPrivateなフィールドを定義するメモ</title>
      <link>http://blog.namiking.net/post/2016/05/flow-class-private-fields/</link>
      <pubDate>Thu, 12 May 2016 08:00:00 +0900</pubDate>
      
      <guid>http://blog.namiking.net/post/2016/05/flow-class-private-fields/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://flowtype.org/&#34;&gt;flow&lt;/a&gt;はJavaScriptの型チェッカーだが、TypeScriptみたくPrivateフィールドを定義できるわけではなく、ちょっとした工夫が必要だったので、メモ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#munge&#34;&gt;flowのmunge_underscoresオプションを使う方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#weakmap&#34;&gt;ES6のWeakMapを使う方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;なんでprivateフィールドが必要:f379f7becb8d42a55814e7f1243a74c2&#34;&gt;なんでPrivateフィールドが必要？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;インスタンス生成後に外部からフィールド値を変更させたくないため。

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ドメイン駆動設計&lt;/strong&gt;(DDD)的なクラス設計をしていると、&lt;strong&gt;イミュータブル(不変)&lt;/strong&gt;のエンティティや値オブジェクトのようなものを多用する。&lt;/li&gt;
&lt;li&gt;イミュータブルであることを保証できれば、安心してインスタンスを参照で保持できる。(DeepCopyをする必要がなくなる)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Public箇所(API)を最小限にしておおきたい。

&lt;ul&gt;
&lt;li&gt;リファクタリングやテスト記述が楽になる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などなど。&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;munge&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;flowのmunge-underscoresオプションを使う方法:f379f7becb8d42a55814e7f1243a74c2&#34;&gt;flowのmunge_underscoresオプションを使う方法&lt;/h2&gt;

&lt;p&gt;flowオプションの&lt;a href=&#34;http://flowtype.org/docs/advanced-configuration.html&#34;&gt;munge_underscores&lt;/a&gt;を有効にすると、先頭に&lt;code&gt;_&lt;/code&gt;(アンダースコア)を付けたフィールド/メソッドは、継承先で使えない。というルールを追加することができる。&lt;/p&gt;

&lt;h3 id=&#34;flowconfig-追記:f379f7becb8d42a55814e7f1243a74c2&#34;&gt;.flowconfig 追記&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;[options]
+ munge_underscores=true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;実装例:f379f7becb8d42a55814e7f1243a74c2&#34;&gt;実装例&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/facebook/flow/blob/7e35d0bd45db81826868022b644c2c2b2b60c895/tests/class_munging/with_munging.js&#34;&gt;GitHub上の使用例&lt;/a&gt;を参考にして、Privateフィールドを実現してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// @flow

type Param = {
  field1: number,
  field2: string,
}

class PrivateSample {
  _param: Param;

  constructor(param: Param) {
    this._param = param;
  }

  getField1(): number {
    return this._param.field1;
  }

  _getField2(): string {
    return this._param.field2;
  }
}

export default class Sample extends PrivateSample {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際にflowをかけると、以下の様なエラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const sample = new Sample({
  field1: 5,
  field2: &amp;quot;test&amp;quot;,
})
assert(sample.getField1() === 5) // OK
assert(sample._getField2() === &amp;quot;test&amp;quot;) // NG
assert(sample._param.field1 === 5) // NG
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;error| property `_param` Property not found in (:0:1,0) Sample
error| property `_getField2` Property not found in (:0:1,0) Sample
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先頭に&lt;code&gt;_&lt;/code&gt;(アンダースコア)、ハンガリアン記法的なキモさがあって、あまり使いたくないが、一番flowっぽい解決法といえる。&lt;/p&gt;

&lt;h3 id=&#34;継承元のクラスを直接インスタンス化すると使えちゃう:f379f7becb8d42a55814e7f1243a74c2&#34;&gt;継承元のクラスを直接インスタンス化すると使えちゃう&lt;/h3&gt;

&lt;p&gt;ちなみに、継承元の&lt;code&gt;PrivateSample&lt;/code&gt;を直接使うと、エラーは出ない。継承しないと効果がないみたいなので、継承元のクラスは&lt;code&gt;export&lt;/code&gt;しないほうが良さそう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const sample = new PrivateSample({
  field1: 5,
  field2: &amp;quot;test&amp;quot;,
})
assert(sample.getField1() === 5) // OK
assert(sample._getField2() === &amp;quot;test&amp;quot;) // OK
assert(sample._param.field1 === 5) // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;weakmap&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;es6のweakmapを使う方法:f379f7becb8d42a55814e7f1243a74c2&#34;&gt;ES6のWeakMapを使う方法&lt;/h2&gt;

&lt;p&gt;flowに限ったものではないが、ES6でPrivateなフィールドを定義する方法論がある。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ES6 class での private プロパティの定義&lt;br /&gt;
&lt;a href=&#34;http://qiita.com/k_ui/items/889ec276fc04b1448674&#34;&gt;http://qiita.com/k_ui/items/889ec276fc04b1448674&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Symbolアクセスを使う方法は、&lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt;を使えば、外部から値を変更することが可能なため、今回は避けた。&lt;/p&gt;

&lt;p&gt;WeakMapでも同じファイル内ならアクセスできるが、インスタンスを作るのは概ね別ファイルなので、あまり問題ないと思った。&lt;/p&gt;

&lt;h3 id=&#34;実装例-1:f379f7becb8d42a55814e7f1243a74c2&#34;&gt;実装例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// @flow

type Param = {
  field1: number,
  field2: string,
}

const privates: WeakMap&amp;lt;Object, Param&amp;gt; = new WeakMap();

export default class Sample {

  constructor(param: Param) {
    privates.set(this, param);
  }

  getField1(): number {
    return privates.get(this).field1;
  }

  getField2(): string {
    return privates.get(this).field2;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;コンソールデバッグがしづらい:f379f7becb8d42a55814e7f1243a74c2&#34;&gt;コンソールデバッグがしづらい&lt;/h3&gt;

&lt;p&gt;WeakMapの方法で、Privateフィールド化していると、コンソールでのデバッグに苦労する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const sample = new Sample({
  field1: 5,
  field2: &amp;quot;test&amp;quot;,
});
console.log(sample);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としても、フィールドの内容は表示されず、以下の様なダンプに。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Sample {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実質、インスタンス内のプロパティには含まれていないので、表示出ないのは当たり前ではある。&lt;code&gt;privates&lt;/code&gt;のWeakMapをダンプすれば、以下の様な表示はされるが、ファイル外からでは参照できないので、厳しい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WeakMap {Sample {} =&amp;gt; Object {field1: 1234, field2: &amp;quot;test&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;おまけ-privateなメソッドも定義できる:f379f7becb8d42a55814e7f1243a74c2&#34;&gt;[おまけ] Privateなメソッドも定義できる？&lt;/h3&gt;

&lt;p&gt;同ファイル内のClass外に関数を定義して、Classメソッド内で使えば実現できなくもない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;const privates: WeakMap&amp;lt;Object, Param&amp;gt; = new WeakMap();

export default class Sample {

  constructor(param: Param) {
    privates.set(this, param);
  }

  getField1(): number {
    return privates.get(this).field1;
  }

  getField2(): string {
    return privates.get(this).field2;
  }
+
+  getPowField1(num: number) {
+    return powField1(this, num);
+  }
}

+// Private method
+function powField1(instance: Sample, num: number) {
+  return Math.pow(privates.get(instance).field1, num);
+}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、ESLintを併用していると、&lt;code&gt;no-use-before-define&lt;/code&gt;に引っかかったりする。
ちとまどろっこしいね。&lt;/p&gt;

&lt;h2 id=&#34;備考-注意点:f379f7becb8d42a55814e7f1243a74c2&#34;&gt;備考・注意点&lt;/h2&gt;

&lt;p&gt;コンストラクタ引数にObjectを渡して、WeakMapにそのままセットする。名前引数的に使えるので、コードの見通しがよくなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const sample = new Sample({
  field1: 1234,
  field2: &amp;quot;Text&amp;quot;,
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、コンストラクタ引数へ渡すObjectを変更可能にしておくと、イミュータブルじゃなくなってしまうので、注意。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let param = {
  field1: 1234,
  field2: &amp;quot;Text&amp;quot;,
};
const sample = new Sample(param);

// non-immutable
param.field1 = 2345;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタ内で、ObjectのShallowCopyを行うなどして、対策すると良いかもしれない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;constructor(param: Param) {
  // ES7の`object-rest-spread`を使うと楽
  Sample.privates.set(this, { ...param });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ:f379f7becb8d42a55814e7f1243a74c2&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;JavaScriptの言語仕様上、Private関係は実装しにくく、どうしてもまどろっこしい書き方になってしまう。それでも、TypeScriptを含め、様々なトランスパイラが生まれた今、以前に比べれば、ずいぶんとPrivateを実現しやすくなったと思う。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;JavaScriptとprivateの見果てぬ夢&lt;br /&gt;
&lt;a href=&#34;http://blog.tojiru.net/article/238901975.html&#34;&gt;http://blog.tojiru.net/article/238901975.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;言語仕様を超える夢を見て、戦い続けた男たちに敬意を表したい。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>