<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ecmascript on Namiking.net</title>
    <link>http://blog.namiking.net/tags/ecmascript/</link>
    <description>Recent content in Ecmascript on Namiking.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp-ja</language>
    <lastBuildDate>Thu, 12 May 2016 08:00:00 +0900</lastBuildDate>
    <atom:link href="http://blog.namiking.net/tags/ecmascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>静的型チェッカーflowのクラスでPrivateなフィールドを定義するメモ</title>
      <link>http://blog.namiking.net/post/2016/05/flow-class-private-fields/</link>
      <pubDate>Thu, 12 May 2016 08:00:00 +0900</pubDate>
      
      <guid>http://blog.namiking.net/post/2016/05/flow-class-private-fields/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://flowtype.org/&#34;&gt;flow&lt;/a&gt;はJavaScriptの型チェッカーだが、TypeScriptみたくPrivateフィールドを定義できるわけではなく、ちょっとした工夫が必要だったので、メモ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ES6のWeakMapが使う方法&#34;&gt;ES6のWeakMapを使う方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#flowのmunge_underscoresオプションを使う&#34;&gt;flowのmunge_underscoresオプションを使う&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;なんでprivateフィールドが必要&#34;&gt;なんでPrivateフィールドが必要？&lt;/h3&gt;

&lt;p&gt;インスタンス生成後に、外部からフィールド値を変更させたくない。&lt;strong&gt;イミュータブル(不変)&lt;/strong&gt;なオブジェクトにしたいため。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ドメイン駆動設計&lt;/strong&gt;(DDD)的なクラス設計をしていると、オブジェクトがネストするような構造を多用する。&lt;/li&gt;
&lt;li&gt;同じインスタンスの複数のオブジェクトが参照することもあり、フィールド値が変更可能だと、&lt;strong&gt;予期せぬ不具合が起こる&lt;/strong&gt;可能性がある。&lt;/li&gt;
&lt;li&gt;だからといって、オブジェクトのDeepCopyはしたくない。&lt;/li&gt;
&lt;li&gt;オブジェクトを参照で保持して、&lt;strong&gt;負荷軽減＆メモリ効率向上&lt;/strong&gt;に期待。(アプリ構造にもよる)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;インスタンス生成から値が変わらないことが保証できれば、クラスを使う側は安心してインスタンスを参照で保持できる。&lt;/p&gt;

&lt;h2 id=&#34;es6のweakmapを使う方法&#34;&gt;ES6のWeakMapを使う方法&lt;/h2&gt;

&lt;p&gt;flowに限ったものではないが、ES6でPrivateなフィールドを定義する方法論がある。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ES6 class での private プロパティの定義&lt;br /&gt;
&lt;a href=&#34;http://qiita.com/k_ui/items/889ec276fc04b1448674&#34;&gt;http://qiita.com/k_ui/items/889ec276fc04b1448674&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Symbolアクセスを使う方法は、&lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt;を使えば、外部から値を変更することが可能なため、今回は避けた。&lt;/p&gt;

&lt;p&gt;WeakMapでも同じファイル内ならアクセスできるが、インスタンスを作るのは概ね別ファイルなので、あまり問題ないと思った。&lt;/p&gt;

&lt;h3 id=&#34;実装例&#34;&gt;実装例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// @flow

type Param = {
  field1: number,
  field2: string,
}

const privates: WeakMap&amp;lt;Object, Param&amp;gt; = new WeakMap();

export default class Sample {

  constructor(param: Param) {
    privates.set(this, param);
  }

  getField1(): number {
    return privates.get(this).field1;
  }

  getField2(): string {
    return privates.get(this).field2;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタ引数にObjectを渡して、WeakMapにそのままセットする。名前引数的に使えるので、コードの見通しがよくなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const sample = new Sample({
  field1: 1234,
  field2: &amp;quot;Text&amp;quot;,
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、コンストラクタ引数へ渡すObjectを変更可能にしておくと、イミュータブルじゃなくなってしまうので、注意。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let param = {
  field1: 1234,
  field2: &amp;quot;Text&amp;quot;,
};
const sample = new Sample(param);

// non-immutable
param.field1 = 2345;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタ内で、ObjectのShallowCopyを行うなどして、対策すると良いかもしれない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;constructor(param: Param) {
  // ES7の`object-rest-spread`を使うと楽
  Sample.privates.set(this, { ...param });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;コンソールデバッグがしづらいデメリット&#34;&gt;コンソールデバッグがしづらいデメリット&lt;/h3&gt;

&lt;p&gt;WeakMapの方法で、Privateフィールド化していると、コンソールでのデバッグに苦労する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const sample = new Sample({
  field1: 5,
  field2: &amp;quot;test&amp;quot;,
});
console.log(sample);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としても、フィールドの内容は表示されず、以下の様なダンプに。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Sample {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実質、インスタンス内のプロパティには含まれていないので、表示出ないのは当たり前ではある。&lt;code&gt;privates&lt;/code&gt;のWeakMapをダンプすれば、以下の様な表示はされるが、ファイル外からでは参照できないので、厳しい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WeakMap {Sample {} =&amp;gt; Object {field1: 1234, field2: &amp;quot;test&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;おまけ-privateなメソッドも定義できる&#34;&gt;[おまけ] Privateなメソッドも定義できる？&lt;/h3&gt;

&lt;p&gt;同ファイル内のClass外に関数を定義して、Classメソッド内で使えば実現できなくもない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;const privates: WeakMap&amp;lt;Object, Param&amp;gt; = new WeakMap();

export default class Sample {

  constructor(param: Param) {
    privates.set(this, param);
  }

  getField1(): number {
    return privates.get(this).field1;
  }

  getField2(): string {
    return privates.get(this).field2;
  }
+
+  getPowField1(num: number) {
+    return powField1(this, num);
+  }
}

+// Private method
+function powField1(instance: Sample, num: number) {
+  return Math.pow(privates.get(instance).field1, num);
+}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、ESLintを併用していると、&lt;code&gt;no-use-before-define&lt;/code&gt;に引っかかったりする。&lt;/p&gt;

&lt;p&gt;ちとまどろっこしいね。&lt;/p&gt;

&lt;h2 id=&#34;flowのmunge-underscoresオプションを使う&#34;&gt;flowのmunge_underscoresオプションを使う&lt;/h2&gt;

&lt;p&gt;flowオプションの&lt;a href=&#34;http://flowtype.org/docs/advanced-configuration.html&#34;&gt;munge_underscores&lt;/a&gt;を有効にすると、先頭に&lt;code&gt;_&lt;/code&gt;(アンダースコア)を付けたフィールド/メソッドは、継承先で使えない。というルールを追加することができる。&lt;/p&gt;

&lt;p&gt;これを利用して、Privateフィールドを実現してみる。
&lt;a href=&#34;https://github.com/facebook/flow/blob/7e35d0bd45db81826868022b644c2c2b2b60c895/tests/class_munging/with_munging.js&#34;&gt;GitHub上の使用例&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;実装例-1&#34;&gt;実装例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// @flow

type Param = {
  field1: number,
  field2: string,
}

class PrivateSample {
  _param: Param;

  constructor(param: Param) {
    this._param = param;
  }

  getField1(): number {
    return this._param.field1;
  }

  _getField2(): string {
    return this._param.field2;
  }
}

export default class Sample extends PrivateSample {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際にflowをかけると、以下の様なエラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const sample = new Sample({
  field1: 5,
  field2: &amp;quot;test&amp;quot;,
})
assert(instance.getField1() === 5) // OK
assert(instance._getField2() === &amp;quot;test&amp;quot;) // NG
assert(instance._param.field1 === 5) // NG
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;error| property `_param` Property not found in (:0:1,0) Sample
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先頭に_(アンダースコア)、ハンガリアン記法的なキモさがあって、あまり使いたくないが、一番flowっぽい解決法といえる。&lt;/p&gt;

&lt;h3 id=&#34;継承元のクラスを直接インスタンス化すると使えちゃう&#34;&gt;継承元のクラスを直接インスタンス化すると使えちゃう&lt;/h3&gt;

&lt;p&gt;ちなみに、継承元の&lt;code&gt;PrivateSample&lt;/code&gt;を直接使うと、エラーは出ない。継承しないと効果がないみたいなので、継承元のクラスは&lt;code&gt;export&lt;/code&gt;しないほうが良さそう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const sample = new PrivateSample({
  field1: 5,
  field2: &amp;quot;test&amp;quot;,
})
assert(instance.getField1() === 5) // OK
assert(instance._getField2() === &amp;quot;test&amp;quot;) // NG
assert(instance._param.field1 === 5) // NG
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>静的型チェッカーflowを使ってみて、微妙に気になったこと４つ</title>
      <link>http://blog.namiking.net/post/2016/05/flow-disadvantage/</link>
      <pubDate>Thu, 12 May 2016 07:00:00 +0900</pubDate>
      
      <guid>http://blog.namiking.net/post/2016/05/flow-disadvantage/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://flowtype.org/&#34;&gt;flow&lt;/a&gt;はJavaScriptの静的型チェックツールの一つ。&lt;/p&gt;

&lt;p&gt;同じような静的型関連ツールであるTypeScriptと比較して、ESLintやBabelとの併用がしやすかったり、型付けが強めだったり(初期からnon-nullableに対応)と、受ける恩恵も多い。&lt;/p&gt;

&lt;p&gt;が、使っていて「おやっ？」っと思う点もいくつかあったので、まとめてみた。&lt;/p&gt;

&lt;h2 id=&#34;気になったこと４つ&#34;&gt;気になったこと４つ&lt;/h2&gt;

&lt;h3 id=&#34;eslintとの併用でめんどうな事が多かった&#34;&gt;ESLintとの併用でめんどうな事が多かった&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/babel/babel-eslint&#34;&gt;babel-eslint&lt;/a&gt;というBabelパーサーを用いれば、概ねのESLintルールがflow文法でも適応できるが、例外もあった。&lt;/p&gt;

&lt;p&gt;例えば、インターフェイスの定義の場合、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface I {
  field: number;
  method(): string;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ESLintの&lt;code&gt;no-undef&lt;/code&gt;ルールを有効にしていると、以下のエラーが発生する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error| &#39;I&#39; is not defined. (no-undef)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ESLintの誤爆ではあるが、そもそも、&lt;code&gt;interface&lt;/code&gt;なんて文法はECMAScriptにはないので、対応しとってのも無茶な話である。&lt;/p&gt;

&lt;p&gt;ESLintの&lt;code&gt;no-undef&lt;/code&gt;まわりを無効にすればエラーは出ないが、有志の方が、flow用のBabelカスタムルールを実装してくれているので、ありがたく利用させていただく。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;GitHub: zertosh/eslint-plugin-flow-vars&lt;br /&gt;
&lt;a href=&#34;https://github.com/zertosh/eslint-plugin-flow-vars&#34;&gt;https://github.com/zertosh/eslint-plugin-flow-vars&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;このBabelプラグインを使ってカスタムルールを有効にすれば、&lt;code&gt;no-undef&lt;/code&gt;を無効にすることなく、ESLintとflowを併用できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// .eslintrc.jsの修正例
module.exports = {
  &amp;quot;parser&amp;quot;: &amp;quot;babel-eslint&amp;quot;,
+ &amp;quot;plugins&amp;quot;:
+   &amp;quot;flow-vars&amp;quot;,
+ ],
  &amp;quot;rules&amp;quot;: {
    &amp;quot;no-undef&amp;quot;: 1,
+   &amp;quot;flow-vars/define-flow-type&amp;quot;: 1,
+   &amp;quot;flow-vars/use-flow-type&amp;quot;: 1,
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;その他、いろいろ試行錯誤している時にTwitter上でご教示いただいたPluginも、いくつかのflow用カスタムルールがあった。不具合があり次第、逐一有効にしていく必要があるかも。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/namikingsoft&#34;&gt;@namikingsoft&lt;/a&gt; eslint-plugin-babel はすでにお試しでしょうか？ eslint 組込ルールの中で、ECMA標準外の構文に起因する誤検知などに対処しているプラグインです。&lt;a href=&#34;https://t.co/CD5p5ejHIq&#34;&gt;https://t.co/CD5p5ejHIq&lt;/a&gt;&lt;/p&gt;&amp;mdash; Toru Nagashima (@mysticatea) &lt;a href=&#34;https://twitter.com/mysticatea/status/728262384771432448&#34;&gt;2016年5月5日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h3 id=&#34;babelを通しても-es6文法で使えないものがある&#34;&gt;Babelを通しても、ES6文法で使えないものがある&lt;/h3&gt;

&lt;p&gt;例えば、&lt;strong&gt;ES6のget/setプロパティ&lt;/strong&gt;が使えなかった。&lt;/p&gt;

&lt;p&gt;イミュータブルなオブジェクトを作って、Privateな値を返すゲッターを作った際、プロパティのように扱えるので、好んで使っていたが、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class A {
  get field(): number {
    return 1234
  }
}

const a = new A()
console.log(a.field)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;flowに通すと、怒られる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error| get/set properties not yet supported
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;yet&lt;/code&gt;ってあるので、いずれサポートされるのだろうか。&lt;/p&gt;

&lt;h3 id=&#34;ジェネリクスなクラス-関数の使い方次第でエラー&#34;&gt;ジェネリクスなクラス/関数の使い方次第でエラー&lt;/h3&gt;

&lt;p&gt;flow的には&lt;strong&gt;Polymorphism&lt;/strong&gt;というのかな？&lt;br /&gt;
TypeScriptやJava感覚で以下のように書くと、flowだとSyntaxエラーになった。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const map = new Map&amp;lt;string, number&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;error| Parsing error: Unexpected token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そもそもBabelがエラーを吐く。&lt;code&gt;babel-plugin-transform-flow-strip-types&lt;/code&gt;の限界っぽい。&lt;/p&gt;

&lt;p&gt;以下のように書くのがflow流っぽいが、なんか冗長な感じがして、あまり好みじゃない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// 変数定義で型を決めとく
const map: WeakMap&amp;lt;string, number&amp;gt; = new WeakMap()

// 型のキャスト
const map = (new WeakMap(): WeakMap&amp;lt;string, number&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数の場合も似たようなSyntaxエラーを吐くが、
以下の様な型推論が効く例だと、逆にスマートな感じで良い。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;function toArray&amp;lt;T&amp;gt;(x: T): Array&amp;lt;T&amp;gt; {
  return [x]
}

// 引数の型(number)を元に、返り値の型(Array&amp;lt;number&amp;gt;)が推論される
const nums = toArray(2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;クラスのフィールド定義などでセミコロンが強制&#34;&gt;クラスのフィールド定義などでセミコロンが強制&lt;/h3&gt;

&lt;p&gt;クラスやインタフェースの定義などで、以下のように書くと、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class A {
  num: number

  constructor(num: number) {
    this.number = num
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次のエラーが、constructorの行で発生する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error| Unexpected identifier
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フィールド定義の行末尾にセミコロン(;)を入れれば、エラーは出ない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;class A {
- num: number
+ num: number;

  constructor(num: number) {
    this.number = num
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アンチ・セミコロン派には吐きそうなほどキツイ仕様。&lt;br /&gt;
&lt;a href=&#34;https://github.com/facebook/flow/issues/825&#34;&gt;https://github.com/facebook/flow/issues/825&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;flowを使ってみて、以下４つの気になったことをまとめてみた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ESLintとの併用でめんどうな事が多かった&lt;/li&gt;
&lt;li&gt;Babelを通しても、ES6文法で使えないものがある&lt;/li&gt;
&lt;li&gt;ジェネリクスなクラス/関数の使い方次第でエラー&lt;/li&gt;
&lt;li&gt;クラスのフィールド定義などでセミコロンが強制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;flowは現在も、定期的にVerUPされているツールなので、今回上げた点もいつの間に修正されているかもしれない。今後も細かく見ていきたい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>サーバーサイドReactをwebpackを使って最小構成で試す (ES6 ＆ TypeScript)</title>
      <link>http://blog.namiking.net/post/2016/02/react-server-using-webpack/</link>
      <pubDate>Sat, 13 Feb 2016 07:30:00 +0900</pubDate>
      
      <guid>http://blog.namiking.net/post/2016/02/react-server-using-webpack/</guid>
      <description>

&lt;p&gt;サーバーサイドのReactに触れたことがなかったので、React+Express+webpackで試してみた。今回試行した手順をチュートリアル的にまとめておく。まずは、シンプルにできそうなECMAScript6で試して、後半にTypeScriptで組んだソースも、おまけ的に載せておきます。&lt;/p&gt;

&lt;h3 id=&#34;この記事の方針&#34;&gt;この記事の方針&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;クライアント -&amp;gt; サーバーサイド -&amp;gt; 結びつける。の順に実装を行う&lt;/li&gt;
&lt;li&gt;なるべくシンプルにするために、実用構成というよりは、最小構成で動かす。

&lt;ul&gt;
&lt;li&gt;コンポーネントのプリレンダやState遷移の確認までを行う。&lt;/li&gt;
&lt;li&gt;サーバーAPIとの通信や画面遷移は、今回扱わない。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;実装するサンプルアプリの内容&#34;&gt;実装するサンプルアプリの内容&lt;/h4&gt;

&lt;p&gt;チュートリアルでよくありそうな、シンプルなカウンターアプリを動かす。
&lt;img src=&#34;http://blog.namiking.net/images/post/2016/02/react-server-using-webpack/sample.png&#34; alt=&#34;Sample&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;事前に必要なソフトウェア&#34;&gt;事前に必要なソフトウェア&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;node.js (v5.6.0)&lt;/li&gt;
&lt;li&gt;npm (v3.6.0)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;現時点の安定版を使ってみたが、そこまで新しくなくても問題ない。&lt;/p&gt;

&lt;h4 id=&#34;memo-利用したnpmパッケージのバージョン&#34;&gt;[Memo] 利用したnpmパッケージのバージョン&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;dependencies&amp;quot;: {
  &amp;quot;express&amp;quot;: &amp;quot;^4.13.4&amp;quot;,
  &amp;quot;react&amp;quot;: &amp;quot;^0.14.7&amp;quot;,
  &amp;quot;react-dom&amp;quot;: &amp;quot;^0.14.7&amp;quot;
},
&amp;quot;devDependencies&amp;quot;: {
  &amp;quot;babel-cli&amp;quot;: &amp;quot;^6.5.1&amp;quot;,
  &amp;quot;babel-loader&amp;quot;: &amp;quot;^6.2.2&amp;quot;,
  &amp;quot;babel-preset-es2015&amp;quot;: &amp;quot;^6.5.0&amp;quot;,
  &amp;quot;babel-preset-react&amp;quot;: &amp;quot;^6.5.0&amp;quot;,
  &amp;quot;dtsm&amp;quot;: &amp;quot;^0.13.0&amp;quot;,
  &amp;quot;ts-loader&amp;quot;: &amp;quot;^0.8.1&amp;quot;,
  &amp;quot;typescript&amp;quot;: &amp;quot;^1.7.5&amp;quot;,
  &amp;quot;webpack&amp;quot;: &amp;quot;^1.12.13&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バージョンが新しくなったりすると、この記事の書き方と変わってくる可能性があるので、注意。&lt;/p&gt;

&lt;h2 id=&#34;ecmascript6-版-チュートリアル&#34;&gt;ECMAScript6 版 (チュートリアル)&lt;/h2&gt;

&lt;p&gt;Reactドキュメントの&lt;a href=&#34;https://facebook.github.io/react/docs/getting-started.html&#34;&gt;Getting Started&lt;/a&gt;でも、Babelを利用しているようなので、まずは、Babelを使って、ECMAScript6で記述できるようにしてみる。なお、サンプルソースの完成版を以下のリポジトリに置いといたので、参考にされたい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ECMAScript6版サンプルソースの完成版&lt;br /&gt;
&lt;a href=&#34;https://github.com/namikingsoft/sample-react-server/tree/typescript&#34;&gt;https://github.com/namikingsoft/sample-react-server/tree/typescript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;まずはクライアント側で動かしてみる&#34;&gt;まずはクライアント側で動かしてみる&lt;/h3&gt;

&lt;p&gt;ファイル構成は以下の様な感じになるように、作業をすすめる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-axapta&#34;&gt;react-server
|-- .babelrc            # Babel設定
|-- package.json        # npm設定
|-- public
|   |-- client.js       # webpackによって吐き出されたフロント用のJS
|   `-- test.html       # クライアント確認用
|-- src
|   |-- client.js       # クライアントJSエントリーポイント
|   `-- components
|       `-- Counter.js  # カウンター用Reactコンポネント
`-- webpack.config.js   # webpack設定
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;npm-init&#34;&gt;npm init&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir react-server
cd react-server

npm init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;適当なディレクトリを作り、package.jsonのテンプレートを作っておく。&lt;code&gt;npm init&lt;/code&gt;の選択肢も全て空Enterで問題ない。&lt;/p&gt;

&lt;h4 id=&#34;必要なnpmパッケージをインストール&#34;&gt;必要なnpmパッケージをインストール&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install --save react react-dom
npm install --save-dev webpack babel-loader babel-preset-es2015 babel-preset-react
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;モダンブラウザによっては、&lt;code&gt;babel-preset-es2015&lt;/code&gt;はいらないかもだが、一応。&lt;/p&gt;

&lt;h4 id=&#34;webpack-config-js&#34;&gt;webpack.config.js&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;var webpack = require(&#39;webpack&#39;);

module.exports = {
  entry: {
    client: &amp;quot;./src/client.js&amp;quot;,
  },
  output: {
    filename: &#39;[name].js&#39;,
    path: &amp;quot;./public&amp;quot;,
  },
  module: {
    loaders: [
      {
        test: /\.jsx?$/,
        loaders: [&#39;babel&#39;],
        exclude: /node_modules/,
      },
    ],
  },
  resolve: {
    extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.jsx&#39;],
    modulesDirectories: [&#39;node_modules&#39;],
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なるべくシンプルにするため、HotLoaderなど記述は入れていない。&lt;/p&gt;

&lt;h4 id=&#34;babelrc&#34;&gt;.babelrc&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;{
  &amp;quot;presets&amp;quot;: [&amp;quot;es2015&amp;quot;, &amp;quot;react&amp;quot;],
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Babelの設定ファイル。&lt;code&gt;React -&amp;gt; ES6 -&amp;gt; ES5&lt;/code&gt;のような感じで、どのブラウザでも割りかし動作するように変換する。&lt;/p&gt;

&lt;h4 id=&#34;public-test-html&#34;&gt;public/test.html&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;App&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script src=&amp;quot;app.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クライアントJSの動作確認用HTML。&lt;code&gt;app.js&lt;/code&gt;が実行された後に、&lt;code&gt;&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;の中身がCounterコンポーネントに置き換わる。&lt;/p&gt;

&lt;h4 id=&#34;src-client-js&#34;&gt;src/client.js&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;
import Counter from &#39;./components/Counter&#39;

ReactDOM.render(
  &amp;lt;Counter /&amp;gt;,
  document.getElementById(&#39;app&#39;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Counterコンポーネントを&lt;code&gt;&amp;lt;div id=&amp;quot;app&amp;quot; /&amp;gt;&lt;/code&gt;に表示する。&lt;/p&gt;

&lt;h4 id=&#34;src-components-counter-js&#34;&gt;src/components/Counter.js&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React, {Component} from &#39;react&#39;

export default class Counter extends Component {

  constructor() {
    super()
    this.state = {
      count: 0
    }
  }

  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;p&amp;gt;Count: {this.state.count}&amp;lt;/p&amp;gt;
        &amp;lt;button onClick={e =&amp;gt; this.increment()}&amp;gt;Increment&amp;lt;/button&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }

  increment() {
    this.setState({
      count: this.state.count + 1
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Incrementボタンを押したら、内部Stateが変化して、コンポーネントを再描写される。&lt;/p&gt;

&lt;h4 id=&#34;webpack実行&#34;&gt;webpack実行&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./node_modules/.bin/webpack
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、&lt;code&gt;public/client.js&lt;/code&gt;にブラウザで動作するJSが生成される。&lt;/p&gt;

&lt;p&gt;webpackコマンドについては、&lt;code&gt;npm run build&lt;/code&gt;コマンドで実行できるように、package.jsonのscriptsに登録しておくと良いかも。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;scripts&amp;quot;: {
  &amp;quot;build&amp;quot;: &amp;quot;webpack&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm run build
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;動作確認&#34;&gt;動作確認&lt;/h4&gt;

&lt;p&gt;Incrementボタンを押して、Stateの変動やコンポーネントの再描写が確認できる。
&lt;img src=&#34;http://blog.namiking.net/images/post/2016/02/react-server-using-webpack/client-result.png&#34; alt=&#34;Client Result&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;サーバーサイドからコンポーネントを描写する&#34;&gt;サーバーサイドからコンポーネントを描写する&lt;/h3&gt;

&lt;p&gt;ファイル構成としては以下。&lt;code&gt;src/server.js&lt;/code&gt;が追加されただけ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-axapta&#34;&gt;react-server
|-- package.json
|-- public
|   |-- client.js
|   `-- test.html
|-- src
|   |-- client.js
|   |-- components
|   |   `-- Counter.js
|   `-- server.js     # 追加: ExpressでCounterコンポーネントをプリレンダリング
`-- webpack.config.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;必要なnpmパッケージをインストール-1&#34;&gt;必要なnpmパッケージをインストール&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install --save express
npm install --save-dev babel-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;軽量Webフレームワークの&lt;code&gt;express&lt;/code&gt;と、node.jsの実行をbabelに通すための&lt;code&gt;babel-cli&lt;/code&gt;をインストールする。&lt;/p&gt;

&lt;h4 id=&#34;src-server-js&#34;&gt;src/server.js&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import express from &#39;express&#39;
import React from &#39;react&#39;
import ReactDOMServer from &#39;react-dom/server&#39;
import Counter from &#39;./components/Counter&#39;

// init express
const app = express()

// add top page routing
app.get(&#39;/&#39;, (req, res) =&amp;gt; {
  res.send(
    ReactDOMServer.renderToString(
      &amp;lt;Counter /&amp;gt;
    )
  )
})

// start listen
app.listen(3000, () =&amp;gt; {
  console.log(&#39;Example app listening on port 3000!&#39;);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ReactDOMServer.renderToString()&lt;/code&gt;を使って、コンポーネントをプリレンダリングできる。&lt;br /&gt;
(HTMLの側端は端折ってます)&lt;/p&gt;

&lt;h4 id=&#34;サーバー起動&#34;&gt;サーバー起動&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;node_modules/.bin/babel-node src/server.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;babel-node&lt;/code&gt;はbabel-cliでインストールされるコマンドで、実行対象のJSを自動的にBabel変換した上でnodeコマンドを実行してくれる便利なラッパー。&lt;/p&gt;

&lt;p&gt;ビルドと同じく、&lt;code&gt;npm start&lt;/code&gt;コマンドで実行できるように、package.jsonのscriptsに登録しておくと良い。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;scripts&amp;quot;: {
  ...
  &amp;quot;start&amp;quot;: &amp;quot;babel-node src/server.js&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm start
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;動作確認-1&#34;&gt;動作確認&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;open http://localhost:3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クライアントのみの実行と、全く同じ画面が表示される。ブラウザのソース表示やcurlなどからも、コンポーネントの中身がプリレンダリングされたHTMLを確認できた。&lt;/p&gt;

&lt;p&gt;しかし。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.namiking.net/images/post/2016/02/react-server-using-webpack/server-result.png&#34; alt=&#34;Client Result&#34; /&gt;&lt;/p&gt;

&lt;p&gt;サーバーサイドでプリレンダしただけで、クライアントでは何もしてないし、react.jsも読み込んでないため、と思われる。&lt;/p&gt;

&lt;h3 id=&#34;サーバーサイドとクライアントの処理をつなげる&#34;&gt;サーバーサイドとクライアントの処理をつなげる&lt;/h3&gt;

&lt;p&gt;Fluxフレームワークで有名なReduxのドキュメントの&lt;a href=&#34;https://github.com/rackt/redux/blob/master/docs/recipes/ServerRendering.md&#34;&gt;Server Rendering&lt;/a&gt;を見るに、サーバーサイドでプリレンダした要素に、再度クライアントからレンダリングをかけている様な処理になっていたので、試してみる。&lt;/p&gt;

&lt;h4 id=&#34;src-server-js-の修正&#34;&gt;src/server.js の修正&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;import express from &#39;express&#39;
import React from &#39;react&#39;
import ReactDOMServer from &#39;react-dom/server&#39;
import Counter from &#39;./components/Counter&#39;

// init express
const app = express()

+ // add static path
+ app.use(express.static(&#39;public&#39;))

// add top page routing
app.get(&#39;/&#39;, (req, res) =&amp;gt; {
  res.send(
    ReactDOMServer.renderToString(
-      &amp;lt;Counter /&amp;gt;
+      &amp;lt;div&amp;gt;
+        &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
+          &amp;lt;Counter /&amp;gt;
+        &amp;lt;/div&amp;gt;
+        &amp;lt;script src=&amp;quot;client.js&amp;quot; /&amp;gt;
+      &amp;lt;/div&amp;gt;
    )
  )
})

// start listen
app.listen(3000, () =&amp;gt; {
  console.log(&#39;Example app listening on port 3000!&#39;);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;app.use(express.static(&#39;public&#39;))&lt;/code&gt;で、publicディレクトリ以下のファイルを静的ファイルとして、読み込み可能として、プリレンダする内容をクライアント側の時に試した&lt;code&gt;test.html&lt;/code&gt;と同じような記述に変更する。&lt;/p&gt;

&lt;h4 id=&#34;再度-動作確認&#34;&gt;再度、動作確認&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm start
open http://localhost:3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今度は、Incrementボタン押下で、正常動作を確認できるはず。&lt;/p&gt;

&lt;h2 id=&#34;typescript-版-要約&#34;&gt;TypeScript 版 (要約)&lt;/h2&gt;

&lt;p&gt;型がついていないと落ち着かない自分のためにも、TypeScriptで導入できるようにもしておきたい。クライアント側は&lt;code&gt;ts-loader&lt;/code&gt;を挟むぐらいで概ね対応できるが、サーバーサイドは&lt;code&gt;babel-node&lt;/code&gt;に相当するものがないようので、一度コンパイルしてから実行するようなイメージ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Typescript版サンプルソースの完成版&lt;br /&gt;
&lt;a href=&#34;https://github.com/namikingsoft/sample-react-server/tree/typescript&#34;&gt;https://github.com/namikingsoft/sample-react-server/tree/typescript&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ECMAScript6版との差分&lt;br /&gt;
&lt;a href=&#34;https://github.com/namikingsoft/sample-react-server/compare/typescript&#34;&gt;https://github.com/namikingsoft/sample-react-server/compare/typescript&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;要約&#34;&gt;要約&lt;/h3&gt;

&lt;p&gt;TypeScript版については、上のようにチュートリアル形式にはせず、要約解説にしたい。詳しくは上の&lt;a href=&#34;https://github.com/namikingsoft/sample-react-server/compare/typescript&#34;&gt;ECMAScript6版との差分&lt;/a&gt;を見ていただいたほうが、早いかもしれない。&lt;/p&gt;

&lt;h4 id=&#34;型定義ファイルマネージャにはdtsmを使った&#34;&gt;型定義ファイルマネージャにはdtsmを使った。&lt;/h4&gt;

&lt;p&gt;npmとほぼ同じインタフェースなので使いやすい。以下コマンド例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install --save-dev dtsm
export PATH=./node_modules/.bin:$PATH

dtsm init
dtsm install --save react.d.ts
dtsm install --save react-dom.d.ts
dtsm install --save express.d.ts
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;サーバーサイドのコンパイルはtscを直接使った&#34;&gt;サーバーサイドのコンパイルはtscを直接使った。&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;babel-node&lt;/code&gt;のようなラッパーコマンドがあることを期待したが、観測内ではなさそうなので、通常通り、&lt;code&gt;dist&lt;/code&gt;ディレクトリあたりに、コンパイル済みのJSを展開して、&lt;code&gt;node dist/server.js&lt;/code&gt;みたいにする作戦にした。&lt;/p&gt;

&lt;p&gt;tsconfig.jsonは以下のとおり。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;target&amp;quot;: &amp;quot;es5&amp;quot;,
    &amp;quot;jsx&amp;quot;: &amp;quot;react&amp;quot;,
    &amp;quot;module&amp;quot;: &amp;quot;commonjs&amp;quot;,
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;,
    &amp;quot;experimentalDecorators&amp;quot;: true,
    &amp;quot;outDir&amp;quot;: &amp;quot;dist&amp;quot;
  },
  &amp;quot;files&amp;quot;: [
    &amp;quot;typings/bundle.d.ts&amp;quot;,
    &amp;quot;src/server.tsx&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、tsconfig.jsonはクライアント側のコンパイルにも使いまわしたいので、React変換なども有効にしてある。&lt;code&gt;experimentalDecorators&lt;/code&gt;はいらないかもだが、ReduxなどのFluxフレームワークで、割りとデコレータ(@connectなど)が使われていたりするので、一応有効にしてある。&lt;/p&gt;

&lt;p&gt;コンパイルについては、package.jsonのscriptsを以下のように修正して、&lt;code&gt;npm run build&lt;/code&gt;でやると良い。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;&amp;quot;scripts&amp;quot;: {
  ...
- &amp;quot;build&amp;quot;: &amp;quot;webpack&amp;quot;,
+ &amp;quot;build&amp;quot;: &amp;quot;webpack &amp;amp;&amp;amp; tsc -p .&amp;quot;,
  ...
},
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm run build
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;クライアントのコンパイルにはwebpackのts-loaderを使った&#34;&gt;クライアントのコンパイルにはwebpackのts-loaderを使った。&lt;/h4&gt;

&lt;p&gt;webpack.config.jsの修正差分は以下の様な感じになる。なお、TypeScript自体が、&lt;code&gt;React -&amp;gt; ES6 -&amp;gt; ES5&lt;/code&gt;変換機能を備えているので、無理にBabelに通さなくてもよい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;var webpack = require(&#39;webpack&#39;);

module.exports = {
  entry: {
-   client: &amp;quot;./src/client.js&amp;quot;,
+   client: &amp;quot;./src/client.tsx&amp;quot;,
  },
  output: {
    filename: &#39;[name].js&#39;,
    path: &amp;quot;./public&amp;quot;,
  },
  module: {
    loaders: [
      {
        test: /\.jsx?$/,
        loaders: [&#39;babel&#39;],
        exclude: /node_modules/,
      },
+     {
+       test: /\.tsx?$/,
+       loaders: [&#39;ts&#39;],
+       exclude: /node_modules/,
+     },
    ],
  },
  resolve: {
-   extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.jsx&#39;],
+   extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.jsx&#39;, &#39;ts&#39;, &#39;.tsx&#39;],
    modulesDirectories: [&#39;node_modules&#39;],
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;あとがき&#34;&gt;あとがき&lt;/h2&gt;

&lt;p&gt;なるべくシンプルな構成で、サーバーサイドReactを試してみた。&lt;/p&gt;

&lt;p&gt;今回はサーバーサイドにExpressを使ってみたが、Railsなどでも、&lt;code&gt;react-rails&lt;/code&gt;のようなgemを利用して、クライアントとの連携ができるはず。&lt;/p&gt;

&lt;p&gt;ReduxやReactRouterなどを利用した、もうちょっと実践的なやり方については、以下のReduxドキュメントやQiita記事が詳しそうだったので、載せておきます。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Redux: Server Rendering&lt;br /&gt;
&lt;a href=&#34;https://github.com/rackt/redux/blob/master/docs/recipes/ServerRendering.md&#34;&gt;https://github.com/rackt/redux/blob/master/docs/recipes/ServerRendering.md&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Qiita: React + Expressでのサーバーサイドレンダリング方法のまとめ&lt;br /&gt;
&lt;a href=&#34;http://qiita.com/hmarui66/items/4f75e624c4f70d596873&#34;&gt;http://qiita.com/hmarui66/items/4f75e624c4f70d596873&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>