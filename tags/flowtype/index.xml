<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Flowtype on Namiking.net</title>
    <link>http://blog.namiking.net/tags/flowtype/</link>
    <description>Recent content in Flowtype on Namiking.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp-ja</language>
    <lastBuildDate>Thu, 12 May 2016 08:00:00 +0900</lastBuildDate>
    <atom:link href="http://blog.namiking.net/tags/flowtype/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>静的型チェッカーflowのクラスでPrivateなフィールドを定義するメモ</title>
      <link>http://blog.namiking.net/post/2016/05/flow-class-private-fields/</link>
      <pubDate>Thu, 12 May 2016 08:00:00 +0900</pubDate>
      
      <guid>http://blog.namiking.net/post/2016/05/flow-class-private-fields/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://flowtype.org/&#34;&gt;flow&lt;/a&gt;はJavaScriptの型チェッカーだが、TypeScriptみたくPrivateフィールドを定義できるわけではなく、ちょっとした工夫が必要だったので、メモ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#weakmap&#34;&gt;ES6のWeakMapを使う方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#munge&#34;&gt;flowのmunge_underscoresオプションを使う&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;なんでprivateフィールドが必要&#34;&gt;なんでPrivateフィールドが必要？&lt;/h3&gt;

&lt;p&gt;インスタンス生成後に、外部からフィールド値を変更させたくない。&lt;strong&gt;イミュータブル(不変)&lt;/strong&gt;なオブジェクトにしたいため。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ドメイン駆動設計&lt;/strong&gt;(DDD)的なクラス設計をしていると、オブジェクトがネストするような構造を多用する。&lt;/li&gt;
&lt;li&gt;同じインスタンスを複数のオブジェクトが参照することもあり、フィールド値が変更可能だと、&lt;strong&gt;予期せぬ不具合が起こる&lt;/strong&gt;可能性がある。&lt;/li&gt;
&lt;li&gt;だからといって、オブジェクトのDeepCopyはしたくない。&lt;/li&gt;
&lt;li&gt;オブジェクトを参照で保持して、&lt;strong&gt;負荷軽減＆メモリ効率向上&lt;/strong&gt;に期待。(アプリ構造にもよる)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;インスタンス生成から値が変わらないことが保証できれば、クラスを使う側は安心してインスタンスを参照で保持できる。&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;weakmap&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;es6のweakmapを使う方法&#34;&gt;ES6のWeakMapを使う方法&lt;/h2&gt;

&lt;p&gt;flowに限ったものではないが、ES6でPrivateなフィールドを定義する方法論がある。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ES6 class での private プロパティの定義&lt;br /&gt;
&lt;a href=&#34;http://qiita.com/k_ui/items/889ec276fc04b1448674&#34;&gt;http://qiita.com/k_ui/items/889ec276fc04b1448674&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Symbolアクセスを使う方法は、&lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt;を使えば、外部から値を変更することが可能なため、今回は避けた。&lt;/p&gt;

&lt;p&gt;WeakMapでも同じファイル内ならアクセスできるが、インスタンスを作るのは概ね別ファイルなので、あまり問題ないと思った。&lt;/p&gt;

&lt;h3 id=&#34;実装例&#34;&gt;実装例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// @flow

type Param = {
  field1: number,
  field2: string,
}

const privates: WeakMap&amp;lt;Object, Param&amp;gt; = new WeakMap();

export default class Sample {

  constructor(param: Param) {
    privates.set(this, param);
  }

  getField1(): number {
    return privates.get(this).field1;
  }

  getField2(): string {
    return privates.get(this).field2;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタ引数にObjectを渡して、WeakMapにそのままセットする。名前引数的に使えるので、コードの見通しがよくなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const sample = new Sample({
  field1: 1234,
  field2: &amp;quot;Text&amp;quot;,
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、コンストラクタ引数へ渡すObjectを変更可能にしておくと、イミュータブルじゃなくなってしまうので、注意。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let param = {
  field1: 1234,
  field2: &amp;quot;Text&amp;quot;,
};
const sample = new Sample(param);

// non-immutable
param.field1 = 2345;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタ内で、ObjectのShallowCopyを行うなどして、対策すると良いかもしれない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;constructor(param: Param) {
  // ES7の`object-rest-spread`を使うと楽
  Sample.privates.set(this, { ...param });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;コンソールデバッグがしづらい&#34;&gt;コンソールデバッグがしづらい&lt;/h3&gt;

&lt;p&gt;WeakMapの方法で、Privateフィールド化していると、コンソールでのデバッグに苦労する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const sample = new Sample({
  field1: 5,
  field2: &amp;quot;test&amp;quot;,
});
console.log(sample);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としても、フィールドの内容は表示されず、以下の様なダンプに。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Sample {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実質、インスタンス内のプロパティには含まれていないので、表示出ないのは当たり前ではある。&lt;code&gt;privates&lt;/code&gt;のWeakMapをダンプすれば、以下の様な表示はされるが、ファイル外からでは参照できないので、厳しい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WeakMap {Sample {} =&amp;gt; Object {field1: 1234, field2: &amp;quot;test&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;おまけ-privateなメソッドも定義できる&#34;&gt;[おまけ] Privateなメソッドも定義できる？&lt;/h3&gt;

&lt;p&gt;同ファイル内のClass外に関数を定義して、Classメソッド内で使えば実現できなくもない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;const privates: WeakMap&amp;lt;Object, Param&amp;gt; = new WeakMap();

export default class Sample {

  constructor(param: Param) {
    privates.set(this, param);
  }

  getField1(): number {
    return privates.get(this).field1;
  }

  getField2(): string {
    return privates.get(this).field2;
  }
+
+  getPowField1(num: number) {
+    return powField1(this, num);
+  }
}

+// Private method
+function powField1(instance: Sample, num: number) {
+  return Math.pow(privates.get(instance).field1, num);
+}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、ESLintを併用していると、&lt;code&gt;no-use-before-define&lt;/code&gt;に引っかかったりする。
ちとまどろっこしいね。&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;munge&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;flowのmunge-underscoresオプションを使う&#34;&gt;flowのmunge_underscoresオプションを使う&lt;/h2&gt;

&lt;p&gt;flowオプションの&lt;a href=&#34;http://flowtype.org/docs/advanced-configuration.html&#34;&gt;munge_underscores&lt;/a&gt;を有効にすると、先頭に&lt;code&gt;_&lt;/code&gt;(アンダースコア)を付けたフィールド/メソッドは、継承先で使えない。というルールを追加することができる。&lt;/p&gt;

&lt;h3 id=&#34;flowconfig-追記&#34;&gt;.flowconfig 追記&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;[options]
+ munge_underscores=true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;実装例-1&#34;&gt;実装例&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/facebook/flow/blob/7e35d0bd45db81826868022b644c2c2b2b60c895/tests/class_munging/with_munging.js&#34;&gt;GitHub上の使用例&lt;/a&gt;を参考にして、Privateフィールドを実現してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// @flow

type Param = {
  field1: number,
  field2: string,
}

class PrivateSample {
  _param: Param;

  constructor(param: Param) {
    this._param = param;
  }

  getField1(): number {
    return this._param.field1;
  }

  _getField2(): string {
    return this._param.field2;
  }
}

export default class Sample extends PrivateSample {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際にflowをかけると、以下の様なエラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const sample = new Sample({
  field1: 5,
  field2: &amp;quot;test&amp;quot;,
})
assert(instance.getField1() === 5) // OK
assert(instance._getField2() === &amp;quot;test&amp;quot;) // NG
assert(instance._param.field1 === 5) // NG
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;error| property `_param` Property not found in (:0:1,0) Sample
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先頭に&lt;code&gt;_&lt;/code&gt;(アンダースコア)、ハンガリアン記法的なキモさがあって、あまり使いたくないが、一番flowっぽい解決法といえる。&lt;/p&gt;

&lt;h3 id=&#34;継承元のクラスを直接インスタンス化すると使えちゃう&#34;&gt;継承元のクラスを直接インスタンス化すると使えちゃう&lt;/h3&gt;

&lt;p&gt;ちなみに、継承元の&lt;code&gt;PrivateSample&lt;/code&gt;を直接使うと、エラーは出ない。継承しないと効果がないみたいなので、継承元のクラスは&lt;code&gt;export&lt;/code&gt;しないほうが良さそう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const sample = new PrivateSample({
  field1: 5,
  field2: &amp;quot;test&amp;quot;,
})
assert(instance.getField1() === 5) // OK
assert(instance._getField2() === &amp;quot;test&amp;quot;) // NG
assert(instance._param.field1 === 5) // NG
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>静的型チェッカーflowを使ってみて、微妙に気になったこと４つ</title>
      <link>http://blog.namiking.net/post/2016/05/flow-disadvantage/</link>
      <pubDate>Thu, 12 May 2016 07:00:00 +0900</pubDate>
      
      <guid>http://blog.namiking.net/post/2016/05/flow-disadvantage/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://flowtype.org/&#34;&gt;flow&lt;/a&gt;はJavaScriptの静的型チェックツールの一つ。&lt;/p&gt;

&lt;p&gt;同じような静的型関連ツールであるTypeScriptと比較して、ESLintやBabelとの併用がしやすかったり、型付けが強めだったり(初期からnon-nullableに対応)と、受ける恩恵も多い。&lt;/p&gt;

&lt;p&gt;が、使っていて「おやっ？」っと思う点もいくつかあったので、まとめてみた。&lt;/p&gt;

&lt;h2 id=&#34;気になったこと４つ&#34;&gt;気になったこと４つ&lt;/h2&gt;

&lt;h3 id=&#34;eslintとの併用でめんどうな事が多かった&#34;&gt;ESLintとの併用でめんどうな事が多かった&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/babel/babel-eslint&#34;&gt;babel-eslint&lt;/a&gt;というBabelパーサーを用いれば、概ねのESLintルールがflow文法でも適応できるが、例外もあった。&lt;/p&gt;

&lt;p&gt;例えば、インターフェイスの定義の場合、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface I {
  field: number;
  method(): string;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ESLintの&lt;code&gt;no-undef&lt;/code&gt;ルールを有効にしていると、以下のエラーが発生する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error| &#39;I&#39; is not defined. (no-undef)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ESLintの誤爆ではあるが、そもそも、&lt;code&gt;interface&lt;/code&gt;なんて文法はECMAScriptにはないので、対応しろっていうのも無茶な話。&lt;/p&gt;

&lt;p&gt;ESLintの&lt;code&gt;no-undef&lt;/code&gt;まわりを無効にすればエラーは出ないが、有志の方が、flow用のBabelカスタムルールを実装してくれているので、ありがたく利用させていただく。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;GitHub: zertosh/eslint-plugin-flow-vars&lt;br /&gt;
&lt;a href=&#34;https://github.com/zertosh/eslint-plugin-flow-vars&#34;&gt;https://github.com/zertosh/eslint-plugin-flow-vars&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;このBabelプラグインを使ってカスタムルールを有効にすれば、&lt;code&gt;no-undef&lt;/code&gt;を無効にすることなく、ESLintとflowを併用できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// .eslintrc.jsの修正例
module.exports = {
  &amp;quot;parser&amp;quot;: &amp;quot;babel-eslint&amp;quot;,
+ &amp;quot;plugins&amp;quot;:
+   &amp;quot;flow-vars&amp;quot;,
+ ],
  &amp;quot;rules&amp;quot;: {
    &amp;quot;no-undef&amp;quot;: 1,
+   &amp;quot;flow-vars/define-flow-type&amp;quot;: 1,
+   &amp;quot;flow-vars/use-flow-type&amp;quot;: 1,
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;その他、いろいろ試行錯誤している時にTwitter上でご教示いただいたPluginも、いくつかのflow用カスタムルールがあった。何かflow+ESLintで不都合があり次第、逐一有効にしていく必要があるかも。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/namikingsoft&#34;&gt;@namikingsoft&lt;/a&gt; eslint-plugin-babel はすでにお試しでしょうか？ eslint 組込ルールの中で、ECMA標準外の構文に起因する誤検知などに対処しているプラグインです。&lt;a href=&#34;https://t.co/CD5p5ejHIq&#34;&gt;https://t.co/CD5p5ejHIq&lt;/a&gt;&lt;/p&gt;&amp;mdash; Toru Nagashima (@mysticatea) &lt;a href=&#34;https://twitter.com/mysticatea/status/728262384771432448&#34;&gt;2016年5月5日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h3 id=&#34;babelを通しても-es6文法で使えないものがある&#34;&gt;Babelを通しても、ES6文法で使えないものがある&lt;/h3&gt;

&lt;p&gt;例えば、&lt;strong&gt;ES6のget/setプロパティ&lt;/strong&gt;が使えなかった。&lt;/p&gt;

&lt;p&gt;イミュータブルなオブジェクトを作って、Privateな値を返すゲッターを作った際、プロパティのように扱えるので、好んで使っていたが、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class A {
  get field(): number {
    return 1234
  }
}

const a = new A()
console.log(a.field)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;flowに通すと、怒られる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error| get/set properties not yet supported
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;yet&lt;/code&gt;ってあるので、いずれサポートされるのだろうか。&lt;/p&gt;

&lt;h3 id=&#34;ジェネリクスなクラス-関数の使い方次第でエラー&#34;&gt;ジェネリクスなクラス/関数の使い方次第でエラー&lt;/h3&gt;

&lt;p&gt;flow的には&lt;strong&gt;Polymorphism&lt;/strong&gt;というのかな？&lt;br /&gt;
TypeScriptやJava感覚で以下のように書くと、flowだとSyntaxエラーになった。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const map = new Map&amp;lt;string, number&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;error| Parsing error: Unexpected token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そもそもBabelがエラーを吐く。&lt;code&gt;babel-plugin-transform-flow-strip-types&lt;/code&gt;の限界っぽい。&lt;/p&gt;

&lt;p&gt;以下のように書くのがflow流っぽいが、なんか冗長な感じがして、あまり好みじゃない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// 変数定義で型を決めとく
const map: WeakMap&amp;lt;string, number&amp;gt; = new WeakMap()

// 型のキャスト
const map = (new WeakMap(): WeakMap&amp;lt;string, number&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数の場合も似たようなSyntaxエラーを吐くが、
以下の様な型推論が効く例だと、逆にスマートな感じで良い。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;function toArray&amp;lt;T&amp;gt;(x: T): Array&amp;lt;T&amp;gt; {
  return [x]
}

// 引数の型(number)を元に、返り値の型(Array&amp;lt;number&amp;gt;)が推論される
const nums = toArray(2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;クラスのフィールド定義などでセミコロンが強制&#34;&gt;クラスのフィールド定義などでセミコロンが強制&lt;/h3&gt;

&lt;p&gt;クラスやインタフェースの定義などで、以下のように書くと、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class A {
  num: number

  constructor(num: number) {
    this.number = num
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次のエラーが、constructorの行で発生する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error| Unexpected identifier
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フィールド定義の行末尾にセミコロン(;)を入れれば、エラーは出ない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;class A {
- num: number
+ num: number;

  constructor(num: number) {
    this.number = num
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アンチ・セミコロン派には吐きそうなほどキツイ仕様。&lt;br /&gt;
&lt;a href=&#34;https://github.com/facebook/flow/issues/825&#34;&gt;https://github.com/facebook/flow/issues/825&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;flowを使ってみて、以下４つの気になったことをまとめてみた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ESLintとの併用でめんどうな事が多かった&lt;/li&gt;
&lt;li&gt;Babelを通しても、ES6文法で使えないものがある&lt;/li&gt;
&lt;li&gt;ジェネリクスなクラス/関数の使い方次第でエラー&lt;/li&gt;
&lt;li&gt;クラスのフィールド定義などでセミコロンが強制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;flowは現在も、定期的にVerUPされているツールなので、今回上げた点もいつの間に修正されているかもしれない。今後も細かく見ていきたい。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>