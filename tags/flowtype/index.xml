<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Flowtype on Namiking.net</title>
    <link>http://blog.namiking.net/tags/flowtype/</link>
    <description>Recent content in Flowtype on Namiking.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp-ja</language>
    <lastBuildDate>Sun, 22 May 2016 20:00:00 +0900</lastBuildDate>
    <atom:link href="http://blog.namiking.net/tags/flowtype/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>静的型チェッカーflowでReact&#43;Reduxのサンプルアプリを組んでみた</title>
      <link>http://blog.namiking.net/post/2016/05/react-redux-using-flow-example/</link>
      <pubDate>Sun, 22 May 2016 20:00:00 +0900</pubDate>
      
      <guid>http://blog.namiking.net/post/2016/05/react-redux-using-flow-example/</guid>
      <description>

&lt;p&gt;JavaScript型チェッカー&lt;a href=&#34;http://flowtype.org/&#34;&gt;flow&lt;/a&gt;を使って、React+Reduxで簡単なカウンターのサンプルアプリケーションを組んでみたので、その際のいくつかのポイントなどをまとめておきます。&lt;/p&gt;

&lt;h3 id=&#34;サンプルアプリについて&#34;&gt;サンプルアプリについて&lt;/h3&gt;

&lt;p&gt;ボタンを押したら数字がインクリメントされるタイプのよくあるサンプルプログラム。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.namiking.net/images/post/2016/05/react-redux-flow-sample/preview.gif&#34; alt=&#34;サンプルアプリPreview&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;GitHub: namikingsoft/react-redux-using-flow-example
&lt;a href=&#34;https://github.com/namikingsoft/react-redux-using-flow-example&#34;&gt;https://github.com/namikingsoft/react-redux-using-flow-example&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;非同期周りの処理に&lt;a href=&#34;https://github.com/yelouafi/redux-saga&#34;&gt;redux-saga&lt;/a&gt;を使ってますが、今回はその辺りの解説は省きます。&lt;/p&gt;

&lt;h2 id=&#34;ポイントいくつか&#34;&gt;ポイントいくつか&lt;/h2&gt;

&lt;p&gt;サンプルアプリ実装の際に、工夫した点/苦労した点を以下にまとめておきました。&lt;/p&gt;

&lt;h3 id=&#34;stateやactionの型定義をする&#34;&gt;StateやActionの型定義をする&lt;/h3&gt;

&lt;p&gt;ReduxのStateやActionのPayload値は、動的言語らしく何でも入れる事が可能です。一人で開発するのなら良いですが、複数人で開発する場合、&lt;strong&gt;Action-&amp;gt;Reducer-&amp;gt;Viewで引き回す型の認識が合わず、思わぬバグが発生&lt;/strong&gt;しかねません。&lt;/p&gt;

&lt;p&gt;なるべく一つの型定義を使いまわし、値の引き回しに規約を与える必要があります。&lt;/p&gt;

&lt;h4 id=&#34;fluxスタンダードなaction型の定義&#34;&gt;FluxスタンダードなAction型の定義&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// src/types/Action.js
export interface Action {
  type: string;
  error?: boolean;
  meta?: any;
}

export interface PayloadAction&amp;lt;T&amp;gt; extends Action {
  payload: T;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Action関数が返すべきオブジェクトの型定義をします。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;GitHub: acdlite/flux-standard-action&lt;br /&gt;
&lt;a href=&#34;https://github.com/acdlite/flux-standard-action&#34;&gt;https://github.com/acdlite/flux-standard-action&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;非公式ではありますが、HumanフレンドリーなAction型として定評のあるFluxスタンダードに沿う形のAction型を組みました。&lt;/p&gt;

&lt;p&gt;個人的に、PayloadがあるActionとないActionとで、型を分けたかったので、分離してあります。Payloadに使う型は以下項目のように、ジェネリクスで指定できます。&lt;/p&gt;

&lt;h4 id=&#34;counter関連の型を定義する&#34;&gt;Counter関連の型を定義する&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// src/types/Counter.js
import type { Action, PayloadAction } from &amp;quot;types/Action&amp;quot;

export interface CounterState {
  num: number;
}

export interface IncrementPayload {
  num: number;
}

export interface IncrementAction extends PayloadAction&amp;lt;IncrementPayload&amp;gt; {}
export interface ResetAction extends Action {}
export type CounterAction = IncrementAction &amp;amp; ResetAction
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;StateやActionの型を一つのファイルに定義しておきます。&lt;/p&gt;

&lt;h3 id=&#34;定義した型をactionやreducerで使い回す&#34;&gt;定義した型をActionやReducerで使い回す&lt;/h3&gt;

&lt;p&gt;上で定義した共通の型設定をAction関数やReducer関数で読み込みます。&lt;/p&gt;

&lt;h4 id=&#34;action関数の定義で使い回す&#34;&gt;Action関数の定義で使い回す&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// src/actions/counter.js
import type { IncrementAction, ResetAction } from &amp;quot;types/Counter&amp;quot;

export const REQUEST_INCREMENT = &amp;quot;COUNTER__REQUEST_INCREMENT&amp;quot;
export const EXECUTE_INCREMENT = &amp;quot;COUNTER__EXECUTE_INCREMENT&amp;quot;
export const RESET = &amp;quot;COUNTER__RESET&amp;quot;

export function requestIncrement(num: number): IncrementAction {
  return { type: REQUEST_INCREMENT, payload: { num } }
}

export function executeIncrement(num: number): IncrementAction {
  return { type: EXECUTE_INCREMENT, payload: { num } }
}

export function reset(): ResetAction {
  return { type: RESET }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;src/types/Counter.js&lt;/code&gt;で定義したものを返り値の型として使いまわしています。Action関数ごとに型定義をするかしないかは、個人の好みとなります。&lt;/p&gt;

&lt;h4 id=&#34;reducer関数の定義で使い回す&#34;&gt;Reducer関数の定義で使い回す&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import { EXECUTE_INCREMENT, RESET } from &amp;quot;actions/counter&amp;quot;
import type { CounterState, CounterAction } from &amp;quot;types/Counter&amp;quot;

export const initialState: CounterState = { num: 0 }

export default function counter(
  state: CounterState = initialState,
  action: CounterAction,
): CounterState {
  switch (action.type) {
    case EXECUTE_INCREMENT: {
      return { num: state.num + action.payload.num }
    }
    case RESET: {
      return { ...initialState }
    }
    default: {
      return state
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actionで使っている&lt;code&gt;CounterAction&lt;/code&gt;は全てのAction関数の返り値型をIntersectionした型です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export type CounterAction = IncrementAction &amp;amp; ResetAction
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のように、Unionにしてもよいのですが、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export type CounterAction = IncrementAction | ResetAction
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;payloadキーが存在するかしないか、逐一チェックする必要があるため、めんどうです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;case EXECUTE_INCREMENT: {
  const incrementNum = action.payload ? action.payload.num || 0 : 0
  return { num: state.num + incrementNum }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;コンポーネントのprops型はプロパティ変数で定義&#34;&gt;コンポーネントのProps型はプロパティ変数で定義&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;props&lt;/code&gt;というプロパティ変数に型をつけることで、ReactのPropTypesのようなチェックをできます。PropTypesは定義方法(isRequredとか)が独特な点、ランタイムエラーしかでない点で、個人的には使いづらい印象でした。&lt;/p&gt;

&lt;p&gt;flowの&lt;code&gt;props&lt;/code&gt;プロパティを利用すれば、実行前の型チェック時にエラーが出るため、見逃しづらいのと、型定義もflowと同様な方法でできるので、統一感が出ます。&lt;/p&gt;

&lt;h4 id=&#34;コンポーネントのプロパティ変数でpropsの型定義ができる&#34;&gt;コンポーネントのプロパティ変数でPropsの型定義ができる&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// src/pages/CounterPage.js を改変
class CounterPage extends Component {
  props: {
    counter: CounterState, // クラス型やオブジェクト型も指定しやすい
    dispatch: (action: Action) =&amp;gt; any, // 関数型も定義可能
    num?: number, // 任意項目については、プロパティ名後ろに`?`をつける
  };
  // ...
  render() {
    const { counter } = this.props // connectしたCounterState型
    const { hoge } = this.props // Err! 未定義のプロパティは取り出せない
    // ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// 使う側の例
render() {
  return &amp;lt;CounterPage num=&amp;quot;String&amp;quot; /&amp;gt; // Err! 型に合わないプロパティは設定できない
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;コンポーネント内で使うactionはconnectしない&#34;&gt;コンポーネント内で使うActionはconnectしない&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;react-redux&lt;/code&gt;のconnectで、Action関数をpropsに関連付けてしまうと、コンポーネントのPropsで、Action関数の型を再定義する必要があります。&lt;/p&gt;

&lt;p&gt;それは面倒＆冗長なので、直接Action関数を使い、その返り値をdispatchすれば、Action関数の元の型定義を使いまわせます。&lt;/p&gt;

&lt;h4 id=&#34;dispatch関数を直接propsに回す&#34;&gt;dispatch関数を直接propsに回す&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// src/pages/CounterPage.js
export default connect(
  ({ counter }) =&amp;gt; ({ counter }),
  dispatch =&amp;gt; ({ dispatch }), // ここ
)(CounterPage)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;action関数をconnectを通さないことで-元の型定義のまま使える&#34;&gt;action関数をconnectを通さないことで、元の型定義のまま使える&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// src/pages/CounterPage.js
import * as actions from &amp;quot;actions/counter&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;handlePressIncrement() {
  const { dispatch } = this.props
  dispatch(actions.executeIncrement(1)) // ここ
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;StateやActionの型定義をする&lt;/li&gt;
&lt;li&gt;定義した型をActionやReducerで使い回す&lt;/li&gt;
&lt;li&gt;コンポーネントのProps型はプロパティ変数で定義&lt;/li&gt;
&lt;li&gt;コンポーネント内で使うActionはconnectしない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;React+Reduxでflowを使った型定義の方法をまとめました。今回はあまり使いませんでしたが、業務ドメイン関係の型定義(ActionのPayloadやStateの中で使う型)は、Reduxなどのフレームワークに依存せず、別フレームワークでも使いまわせる可能性があるので、積極的に型定義をしていきたいです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>静的型チェッカーflowのクラスでPrivateなフィールドを定義するメモ</title>
      <link>http://blog.namiking.net/post/2016/05/flow-class-private-fields/</link>
      <pubDate>Thu, 12 May 2016 08:00:00 +0900</pubDate>
      
      <guid>http://blog.namiking.net/post/2016/05/flow-class-private-fields/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://flowtype.org/&#34;&gt;flow&lt;/a&gt;はJavaScriptの型チェッカーだが、TypeScriptみたくPrivateフィールドを定義できるわけではなく、ちょっとした工夫が必要だったので、メモ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#munge&#34;&gt;flowのmunge_underscoresオプションを使う方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#weakmap&#34;&gt;ES6のWeakMapを使う方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;なんでprivateフィールドが必要&#34;&gt;なんでPrivateフィールドが必要？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;インスタンス生成後に外部からフィールド値を変更させたくないため。

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ドメイン駆動設計&lt;/strong&gt;(DDD)的なクラス設計をしていると、&lt;strong&gt;イミュータブル(不変)&lt;/strong&gt;のエンティティや値オブジェクトのようなものを多用する。&lt;/li&gt;
&lt;li&gt;イミュータブルであることを保証できれば、安心してインスタンスを参照で保持できる。(DeepCopyをする必要がなくなる)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Public箇所(API)を最小限にしておおきたい。

&lt;ul&gt;
&lt;li&gt;リファクタリングやテスト記述が楽になる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などなど。&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;munge&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;flowのmunge-underscoresオプションを使う方法&#34;&gt;flowのmunge_underscoresオプションを使う方法&lt;/h2&gt;

&lt;p&gt;flowオプションの&lt;a href=&#34;http://flowtype.org/docs/advanced-configuration.html&#34;&gt;munge_underscores&lt;/a&gt;を有効にすると、先頭に&lt;code&gt;_&lt;/code&gt;(アンダースコア)を付けたフィールド/メソッドは、継承先で使えない。というルールを追加することができる。&lt;/p&gt;

&lt;h3 id=&#34;flowconfig-追記&#34;&gt;.flowconfig 追記&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;[options]
+ munge_underscores=true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;実装例&#34;&gt;実装例&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/facebook/flow/blob/7e35d0bd45db81826868022b644c2c2b2b60c895/tests/class_munging/with_munging.js&#34;&gt;GitHub上の使用例&lt;/a&gt;を参考にして、Privateフィールドを実現してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// @flow

type Param = {
  field1: number,
  field2: string,
}

class PrivateSample {
  _param: Param;

  constructor(param: Param) {
    this._param = param;
  }

  getField1(): number {
    return this._param.field1;
  }

  _getField2(): string {
    return this._param.field2;
  }
}

export default class Sample extends PrivateSample {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際にflowをかけると、以下の様なエラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const sample = new Sample({
  field1: 5,
  field2: &amp;quot;test&amp;quot;,
})
assert(sample.getField1() === 5) // OK
assert(sample._getField2() === &amp;quot;test&amp;quot;) // NG
assert(sample._param.field1 === 5) // NG
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;error| property `_param` Property not found in (:0:1,0) Sample
error| property `_getField2` Property not found in (:0:1,0) Sample
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先頭に&lt;code&gt;_&lt;/code&gt;(アンダースコア)、ハンガリアン記法的なキモさがあって、あまり使いたくないが、一番flowっぽい解決法といえる。&lt;/p&gt;

&lt;h3 id=&#34;継承元のクラスを直接インスタンス化すると使えちゃう&#34;&gt;継承元のクラスを直接インスタンス化すると使えちゃう&lt;/h3&gt;

&lt;p&gt;ちなみに、継承元の&lt;code&gt;PrivateSample&lt;/code&gt;を直接使うと、エラーは出ない。継承しないと効果がないみたいなので、継承元のクラスは&lt;code&gt;export&lt;/code&gt;しないほうが良さそう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const sample = new PrivateSample({
  field1: 5,
  field2: &amp;quot;test&amp;quot;,
})
assert(sample.getField1() === 5) // OK
assert(sample._getField2() === &amp;quot;test&amp;quot;) // OK
assert(sample._param.field1 === 5) // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;weakmap&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;es6のweakmapを使う方法&#34;&gt;ES6のWeakMapを使う方法&lt;/h2&gt;

&lt;p&gt;flowに限ったものではないが、ES6でPrivateなフィールドを定義する方法論がある。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ES6 class での private プロパティの定義&lt;br /&gt;
&lt;a href=&#34;http://qiita.com/k_ui/items/889ec276fc04b1448674&#34;&gt;http://qiita.com/k_ui/items/889ec276fc04b1448674&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Symbolアクセスを使う方法は、&lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt;を使えば、外部から値を変更することが可能なため、今回は避けた。&lt;/p&gt;

&lt;p&gt;WeakMapでも同じファイル内ならアクセスできるが、インスタンスを作るのは概ね別ファイルなので、あまり問題ないと思った。&lt;/p&gt;

&lt;h3 id=&#34;実装例-1&#34;&gt;実装例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// @flow

type Param = {
  field1: number,
  field2: string,
}

const privates: WeakMap&amp;lt;Object, Param&amp;gt; = new WeakMap();

export default class Sample {

  constructor(param: Param) {
    privates.set(this, param);
  }

  getField1(): number {
    return privates.get(this).field1;
  }

  getField2(): string {
    return privates.get(this).field2;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;コンソールデバッグがしづらい&#34;&gt;コンソールデバッグがしづらい&lt;/h3&gt;

&lt;p&gt;WeakMapの方法で、Privateフィールド化していると、コンソールでのデバッグに苦労する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const sample = new Sample({
  field1: 5,
  field2: &amp;quot;test&amp;quot;,
});
console.log(sample);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としても、フィールドの内容は表示されず、以下の様なダンプに。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Sample {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実質、インスタンス内のプロパティには含まれていないので、表示出ないのは当たり前ではある。&lt;code&gt;privates&lt;/code&gt;のWeakMapをダンプすれば、以下の様な表示はされるが、ファイル外からでは参照できないので、厳しい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WeakMap {Sample {} =&amp;gt; Object {field1: 1234, field2: &amp;quot;test&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;おまけ-privateなメソッドも定義できる&#34;&gt;[おまけ] Privateなメソッドも定義できる？&lt;/h3&gt;

&lt;p&gt;同ファイル内のClass外に関数を定義して、Classメソッド内で使えば実現できなくもない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;const privates: WeakMap&amp;lt;Object, Param&amp;gt; = new WeakMap();

export default class Sample {

  constructor(param: Param) {
    privates.set(this, param);
  }

  getField1(): number {
    return privates.get(this).field1;
  }

  getField2(): string {
    return privates.get(this).field2;
  }
+
+  getPowField1(num: number) {
+    return powField1(this, num);
+  }
}

+// Private method
+function powField1(instance: Sample, num: number) {
+  return Math.pow(privates.get(instance).field1, num);
+}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、ESLintを併用していると、&lt;code&gt;no-use-before-define&lt;/code&gt;に引っかかったりする。
ちとまどろっこしいね。&lt;/p&gt;

&lt;h2 id=&#34;備考-注意点&#34;&gt;備考・注意点&lt;/h2&gt;

&lt;p&gt;コンストラクタ引数にObjectを渡して、WeakMapにそのままセットする。名前引数的に使えるので、コードの見通しがよくなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const sample = new Sample({
  field1: 1234,
  field2: &amp;quot;Text&amp;quot;,
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、コンストラクタ引数へ渡すObjectを変更可能にしておくと、イミュータブルじゃなくなってしまうので、注意。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let param = {
  field1: 1234,
  field2: &amp;quot;Text&amp;quot;,
};
const sample = new Sample(param);

// non-immutable
param.field1 = 2345;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタ内で、ObjectのShallowCopyを行うなどして、対策すると良いかもしれない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;constructor(param: Param) {
  // ES7の`object-rest-spread`を使うと楽
  Sample.privates.set(this, { ...param });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;JavaScriptの言語仕様上、Private関係は実装しにくく、どうしてもまどろっこしい書き方になってしまう。それでも、TypeScriptを含め、様々なトランスパイラが生まれた今、以前に比べれば、ずいぶんとPrivateを実現しやすくなったと思う。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;JavaScriptとprivateの見果てぬ夢&lt;br /&gt;
&lt;a href=&#34;http://blog.tojiru.net/article/238901975.html&#34;&gt;http://blog.tojiru.net/article/238901975.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;言語仕様を超える夢を見て、戦い続けた男たちに敬意を表したい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>静的型チェッカーflowを使ってみて、微妙に気になったこと４つ</title>
      <link>http://blog.namiking.net/post/2016/05/flow-disadvantage/</link>
      <pubDate>Thu, 12 May 2016 07:00:00 +0900</pubDate>
      
      <guid>http://blog.namiking.net/post/2016/05/flow-disadvantage/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://flowtype.org/&#34;&gt;flow&lt;/a&gt;はJavaScriptの静的型チェックツールの一つ。&lt;/p&gt;

&lt;p&gt;同じような静的型関連ツールであるTypeScriptと比較して、ESLintやBabelとの併用がしやすかったり、型付けが強めだったり(初期からnon-nullableに対応)と、受ける恩恵も多い。&lt;/p&gt;

&lt;p&gt;が、使っていて「おやっ？」っと思う点もいくつかあったので、まとめてみた。&lt;/p&gt;

&lt;h2 id=&#34;気になったこと４つ&#34;&gt;気になったこと４つ&lt;/h2&gt;

&lt;h3 id=&#34;eslintとの併用でめんどうな事が多かった&#34;&gt;ESLintとの併用でめんどうな事が多かった&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/babel/babel-eslint&#34;&gt;babel-eslint&lt;/a&gt;というBabelパーサーを用いれば、概ねのESLintルールがflow文法でも適応できるが、例外もあった。&lt;/p&gt;

&lt;p&gt;例えば、インターフェイスの定義の場合、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface I {
  field: number;
  method(): string;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ESLintの&lt;code&gt;no-undef&lt;/code&gt;ルールを有効にしていると、以下のエラーが発生する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error| &#39;I&#39; is not defined. (no-undef)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ESLintの誤爆ではあるが、そもそも、&lt;code&gt;interface&lt;/code&gt;なんて文法はECMAScriptにはないので、対応しろっていうのも無茶な話。&lt;/p&gt;

&lt;p&gt;ESLintの&lt;code&gt;no-undef&lt;/code&gt;まわりを無効にすればエラーは出ないが、有志の方が、flow用のBabelカスタムルールを実装してくれているので、ありがたく利用させていただく。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;GitHub: zertosh/eslint-plugin-flow-vars&lt;br /&gt;
&lt;a href=&#34;https://github.com/zertosh/eslint-plugin-flow-vars&#34;&gt;https://github.com/zertosh/eslint-plugin-flow-vars&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;このBabelプラグインを使ってカスタムルールを有効にすれば、&lt;code&gt;no-undef&lt;/code&gt;を無効にすることなく、ESLintとflowを併用できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// .eslintrc.jsの修正例
module.exports = {
  &amp;quot;parser&amp;quot;: &amp;quot;babel-eslint&amp;quot;,
+ &amp;quot;plugins&amp;quot;:
+   &amp;quot;flow-vars&amp;quot;,
+ ],
  &amp;quot;rules&amp;quot;: {
    &amp;quot;no-undef&amp;quot;: 1,
+   &amp;quot;flow-vars/define-flow-type&amp;quot;: 1,
+   &amp;quot;flow-vars/use-flow-type&amp;quot;: 1,
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;その他、いろいろ試行錯誤している時にTwitter上でご教示いただいたPluginも、いくつかのflow用カスタムルールがあった。何かflow+ESLintで不都合があり次第、逐一有効にしていく必要があるかも。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/namikingsoft&#34;&gt;@namikingsoft&lt;/a&gt; eslint-plugin-babel はすでにお試しでしょうか？ eslint 組込ルールの中で、ECMA標準外の構文に起因する誤検知などに対処しているプラグインです。&lt;a href=&#34;https://t.co/CD5p5ejHIq&#34;&gt;https://t.co/CD5p5ejHIq&lt;/a&gt;&lt;/p&gt;&amp;mdash; Toru Nagashima (@mysticatea) &lt;a href=&#34;https://twitter.com/mysticatea/status/728262384771432448&#34;&gt;2016年5月5日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h3 id=&#34;babelを通しても-es6文法で使えないものがある&#34;&gt;Babelを通しても、ES6文法で使えないものがある&lt;/h3&gt;

&lt;p&gt;例えば、&lt;strong&gt;ES6のget/setプロパティ&lt;/strong&gt;が使えなかった。&lt;/p&gt;

&lt;p&gt;イミュータブルなオブジェクトを作って、Privateな値を返すゲッターを作った際、プロパティのように扱えるので、好んで使っていたが、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class A {
  get field(): number {
    return 1234
  }
}

const a = new A()
console.log(a.field)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;flowに通すと、怒られる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error| get/set properties not yet supported
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;yet&lt;/code&gt;ってあるので、いずれサポートされるのだろうか。&lt;/p&gt;

&lt;h3 id=&#34;ジェネリクスなクラス-関数の使い方次第でエラー&#34;&gt;ジェネリクスなクラス/関数の使い方次第でエラー&lt;/h3&gt;

&lt;p&gt;flow的には&lt;strong&gt;Polymorphism&lt;/strong&gt;というのかな？&lt;br /&gt;
TypeScriptやJava感覚で以下のように書くと、flowだとSyntaxエラーになった。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const map = new Map&amp;lt;string, number&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;error| Parsing error: Unexpected token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そもそもBabelがエラーを吐く。&lt;code&gt;babel-plugin-transform-flow-strip-types&lt;/code&gt;の限界っぽい。&lt;/p&gt;

&lt;p&gt;以下のように書くのがflow流っぽいが、なんか冗長な感じがして、あまり好みじゃない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// 変数定義で型を決めとく
const map: WeakMap&amp;lt;string, number&amp;gt; = new WeakMap()

// 型のキャスト
const map = (new WeakMap(): WeakMap&amp;lt;string, number&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数の場合も似たようなSyntaxエラーを吐くが、
以下の様な型推論が効く例だと、逆にスマートな感じで良い。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;function toArray&amp;lt;T&amp;gt;(x: T): Array&amp;lt;T&amp;gt; {
  return [x]
}

// 引数の型(number)を元に、返り値の型(Array&amp;lt;number&amp;gt;)が推論される
const nums = toArray(2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;クラスのフィールド定義などでセミコロンが強制&#34;&gt;クラスのフィールド定義などでセミコロンが強制&lt;/h3&gt;

&lt;p&gt;クラスやインタフェースの定義などで、以下のように書くと、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class A {
  num: number

  constructor(num: number) {
    this.number = num
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次のエラーが、constructorの行で発生する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error| Unexpected identifier
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フィールド定義の行末尾にセミコロン(;)を入れれば、エラーは出ない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;class A {
- num: number
+ num: number;

  constructor(num: number) {
    this.number = num
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アンチ・セミコロン派には吐きそうなほどキツイ仕様。&lt;br /&gt;
&lt;a href=&#34;https://github.com/facebook/flow/issues/825&#34;&gt;https://github.com/facebook/flow/issues/825&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;flowを使ってみて、以下４つの気になったことをまとめてみた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ESLintとの併用でめんどうな事が多かった&lt;/li&gt;
&lt;li&gt;Babelを通しても、ES6文法で使えないものがある&lt;/li&gt;
&lt;li&gt;ジェネリクスなクラス/関数の使い方次第でエラー&lt;/li&gt;
&lt;li&gt;クラスのフィールド定義などでセミコロンが強制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;flowは現在も、定期的にVerUPされているツールなので、今回上げた点もいつの間に修正されているかもしれない。今後も細かく見ていきたい。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>